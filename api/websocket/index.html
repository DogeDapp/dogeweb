<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>websocket - WebSocket 13 support</title>
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.css">
    <link rel="stylesheet" href="../style.css">
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>
    <script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
  </head>
  <body>
    <div class="navbar" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../">dogeweb</a>
        </div>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li><a href="https://github.com/pyos/dogeweb">GitHub</a></li>
            <li><a href="../">API docs</a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="container">
      <h1>websocket - WebSocket 13 support</h1>
    </div>
    <div class="section-wrapper section-wrapper-class" id="Message">
  <div class="container section section-class">
    <h2><span class='decl-name' id='Message'>Message</span></h2>
    <p>A single WebSocket message. Note that you&rsquo;ll be seeing the subclasses of this instead;
see below.</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-attribute" id="is_ping">
  <div class="container section section-attribute">
    <h2><span class='decl-name' id='is_ping'>is_ping</span></h2>
    <p>Should never appear if you&rsquo;re using a <a href="#Reader">Reader</a> (it handles pings automatically.)</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-attribute" id="is_pong">
  <div class="container section section-attribute">
    <h2><span class='decl-name' id='is_pong'>is_pong</span></h2>
    <p>Whether this message is a response to a previously sent ping.</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-attribute" id="is_data">
  <div class="container section section-attribute">
    <h2><span class='decl-name' id='is_data'>is_data</span></h2>
    <p>Whether this message is some binary data.</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-attribute" id="is_text">
  <div class="container section section-attribute">
    <h2><span class='decl-name' id='is_text'>is_text</span></h2>
    <p>Whether this message is text (in UTF-8, I think?)</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-attribute" id="is_close">
  <div class="container section section-attribute">
    <h2><span class='decl-name' id='is_close'>is_close</span></h2>
    <p>Whether this message is the last one sent over this channel.
The connection has already been closed.</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-class" id="DataMessage">
  <div class="container section section-class">
    <h2><span class='decl-name' id='DataMessage'>DataMessage</span></h2>
    <p>A message with type other than &ldquo;text&rdquo;. Is a subclass of <code>bytes</code>; contains the data.</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-class" id="TextMessage">
  <div class="container section section-class">
    <h2><span class='decl-name' id='TextMessage'>TextMessage</span></h2>
    <p>A message with type &ldquo;text&rdquo;. Is a subclass of <code>str</code>; contains the data, too.</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-class" id="WebSocket">
  <div class="container section section-class">
    <h2><span class='decl-name' id='WebSocket'>WebSocket</span></h2>
    <p>A special coroutine-like object that waits for the next message and returns it
when used with <code>yield from</code>. Raises <code>asyncio.CancelledError</code> if the connection
gets closed; the first argument of the exception, if it exists, is
a <a href="#Message">Message</a> received before closing the connection (it will have <code>is_close</code>
set to <code>True</code>.) Other than that, it can send data, too:</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-method" id="ping">
  <div class="container section section-method">
    <h2><span class='decl-name' id='ping'>ping</span> <span class='decl-arg'>payload</span></h2>
    <p>Send a ping. This method is a <em>coroutine</em> which waits until all data is sent.
(Note that waiting on it is not necessary to send data; feel free to forget the
<code>yield from</code>.)</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-method" id="pong">
  <div class="container section section-method">
    <h2><span class='decl-name' id='pong'>pong</span> <span class='decl-arg'>payload</span></h2>
    <p>Respond to a ping. Done automatically. Also a coroutine.</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-method" id="text">
  <div class="container section section-method">
    <h2><span class='decl-name' id='text'>text</span> <span class='decl-arg'>payload</span></h2>
    <p>Send some text. A coroutine.</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-method" id="data">
  <div class="container section section-method">
    <h2><span class='decl-name' id='data'>data</span> <span class='decl-arg'>payload</span></h2>
    <p>Send some binary data. A coroutine.</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-method" id="close">
  <div class="container section section-method">
    <h2><span class='decl-name' id='close'>close</span> <span class='decl-arg decl-arg-opt'>code</span> <span class='decl-arg decl-arg-opt'>data</span></h2>
    <p>Send a <code>close</code> message. <strong>No other messages can be sent after that.</strong>
This method also cancels the task that calls it, just to drive that point home.
A coroutine.</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-method" id="mux">
  <div class="container section section-method">
    <h2><span class='decl-name' id='mux'>mux</span> <span class='decl-arg decl-arg-var'>streams</span></h2>
    <p>Connect multiple <a href="#WebSocket">WebSocket</a> streams into a
read-only one that emits data from all of these streams. Instead of just <code>message</code>, it
returns <code>(stream, message)</code> pairs when yielded from. The first websocket to disconnect
cancels the task.</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-function" id="endpoint">
  <div class="container section section-function">
    <h2><span class='decl-name' id='endpoint'>endpoint</span> <span class='decl-arg'>handler</span></h2>
    <p>Create a request handler that establishes a WebSocket connection and calls into
the handler, which should accept all the same arguments as a normal request handler
would with the addition of one more positional argument, which is a <a href="#WebSocket">WebSocket</a>
object.</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-function" id="aggregate">
  <div class="container section section-function">
    <h2><span class='decl-name' id='aggregate'>aggregate</span> <span class='decl-arg'>n</span> <span class='decl-arg'>handler</span></h2>
    <p>Same as <a href="#endpoint">endpoint</a>, only instead of a single connection the handler should
accept a set of <code>n</code> connections. The clients may have to wait until there are
enough connections to call the handler.</p>

  </div>
</div>
<div class="section-wrapper section-wrapper-function" id="client">
  <div class="container section section-function">
    <h2><span class='decl-name' id='client'>client</span> <span class='decl-arg'>path</span> <span class='decl-arg'>reader</span> <span class='decl-arg'>writer</span></h2>
    <p>Create a client-side half of the WebSocket stream given a standard asyncio <code>StreamReader</code>
and <code>StreamWriter</code>. Note that this is a server-side framework, so client-side functionality
is not really outstanding; for example, this function only supports HTTP/1.1 and only
sends the minimal headers (which are hardcoded). Returns a <a href="#WebSocket">WebSocket</a>
object.</p>
<div class="highlight"><pre><span class="n">io</span> <span class="o">=</span> <span class="kr">yield</span> <span class="n">from</span> <span class="o">$</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">open_connection</span> <span class="s">&#39;websocket.host&#39;</span> <span class="mi">80</span>
<span class="n">ws</span> <span class="o">=</span> <span class="kr">yield</span> <span class="n">from</span> <span class="o">$</span> <span class="n">websocket</span><span class="o">.</span><span class="n">client</span> <span class="s">&#39;/websocket_node/&#39;</span> <span class="o">*:</span> <span class="n">io</span>
<span class="n">ws</span><span class="o">.</span><span class="n">text</span> <span class="s">&#39;ok&#39;</span>
</pre></div>

  </div>
</div>
    <div class="footer">
      <div class="container">
        <p>^C Interrupted by EOF</p>
        <p>Made by <a href="https://github.com/pyos">pyos</a>.</p>
      </div>
    </div>
  </body>
</html>

