import '/re'
import '/itertools'


#: Concatenate the result of calling two functions with the same arguments.
#: Used to construct paths.
#:
#: concatfs :: (**a -> str) (**a -> str) -> **a -> str
#:
concatfs = f g -> **: k -> f **: k + g **: k


#: Call a function if it is indeed a function; if it's actually a property,
#: call its `fget` method. Allows to use `~> methods` as routes.
#:
#: callprop :: (Either (*a **b -> c) (property c)) *a **b -> c
#:
callprop = f *: a **: kw -> if
  f :: property => f.fget *: a **: kw
  otherwise     => f      *: a **: kw


#: The wild cards available for use in path routes. The first item
#: is the regex to use; the second is a function that parses the result.
#:
#: wildcards :: dict str (str, (str -> object))
#:
wildcards = dict'
  'str',  ('[^/]+', str)
  'path', ('.+',    str)
  'int',  ('\d+',   int)


#: Given a path route, convert it into a regex that only matches appropriate requests.
#: Constructs of form `<type:name>` are converted into named groups; the exact contents
#: of these groups are determined by `wildcards`. The other returned object
#: is a dict that maps field names to functions that parse their contents.
#:
#: pathregex :: str -> (dict str (str -> object), Regex)
#:
pathregex = path ->
  fnmap = dict!
  cards = re.split r'<([\w_]+):([\w_]+)>' path
  # For some reason, a regex match is flattened into the list returned by `cards`
  # instead of staying a tuple. Ugh.
  plain = cards !! slice 0 None 3
  types = cards !! slice 1 None 3
  names = cards !! slice 2 None 3

  onwildcard = wcid name -> if
    name in fnmap     => raise $ ValueError $ '{!r} contains repeating names'.format path
    wcid in wildcards =>
      fnmap !! name = wildcards !! wcid !! 1
      '(?P<{}>{})'.format name $ wildcards !! wcid !! 0
    otherwise => raise $ ValueError $ 'wildcard type {!r} not supported'.format wcid

  fnmap, re.compile $ ''.join $ map ''.join $ itertools.zip_longest fillvalue: ''
    map re.escape  plain
    map onwildcard types names


#: Given a function that decides between multiple routes based on the requested path,
#: create one that
#:
#:   1. Allows for wildcards in these paths; e.g. `/<str:board>/<int:post>/`
#:      would match both `/b/1/` and `/s/100/`.
#:
#:   2. Allows for route names; in addition to `(path, handler)` tuples, it can accept
#:      `(path, name, handler)` tuples. These names could then be used to construct
#:      an URL without hardcoding the routes themselves.
#:
#:   3. For each route that ends with a slash creates one that does not, but redirects
#:      to the former. (e.g. if there's a route for `/something/`, `/something`
#:      would redirect there.)
#:
#: pathrouter :: (Router (dict str (str -> object), Regex)) (Optional bool) -> Router str
#:
pathrouter = f no_bare: False -> *: xs ->
  routemap = dict!
  routerev = dict!
  router   = f routerev: routerev *:
    where for q in xs =>
      data, name, h = if
        len q > 2 => q !! 0, q !! 1, q !! 2
        otherwise => q !! 0, None,   q !! 1
      name = name or getattr h '__name__' None

      data = re.sub r'/+' '/' data
      bare = '/' + data.strip '/'

      if data == bare and bare != '/' and no_bare =>
        raise $ ValueError $ '{!r} must end with a slash'.format data

      name =>
        routemap !! name = (data -> **: k -> data) data
        routerev !! h    = name
        hasattr h 'routemap' => for (r, v) in h.routemap.items! =>
          routemap !! (name + '.' + r) = concatfs (routemap !! name) v

      data_re = pathregex data
      bare_re = pathregex bare

      if data == bare => yield (data_re, h)
         otherwise    =>
           yield (data_re, h)
           yield (bare_re, **: _ ~> @redirect $ @fullpath + '/')
  router.routemap = routemap
  router.routerev = routerev
  router


#: Check whether a requested `Host` is a subdomain of another.
#:
#: _issubdomainof :: str str -> bool
#:
_issubdomainof = host mask -> mask == host or host.endswith ('.' + mask)


#: Check whether a path is a subpath of another one. Return the length
#: of the matched component and a dictionary of groups.
#:
#: _issubpathof :: str (dict str (str -> object), Regex) -> Maybe (int, dict str object)
#:
_issubpathof = path (fns, regex) -> (m = regex.match path) => m.end! - 1, dict
  where for (name, value) in m.groupdict!.items! =>
    yield (name, (fns !! name) value)


#: Check whether a path matches the route exactly. Return value is the same
#: as for `_issubpathof`.
#:
#: _issameas :: str (dict str (str -> object), Regex) -> Maybe (int, dict str object)
#:
_issameas = path (fns, regex) -> (m = regex.match path) and m.end! == len path => m.end!,
  where for (name, value) in m.groupdict!.items! =>
    yield (name, (fns !! name) value)


#: Route on HTTP method. Method names are uppercase.
#: `HEAD` is routed to `GET` unless redefined.
#:
#: method :: Router str
#:
method = *: choices -> req **: k -> next $
  where
    for (method, fn) in choices =>
      if method == req.method or (req.method == 'HEAD' and method == 'GET') =>
        yield $ callprop fn req **: k
    req.abort 405


#: Route on HTTP path. If a request was made to `/something` and a route was found
#: that matches `/something/`, a redirect is issued.
#:
#: file :: Router str
#:
file = pathrouter $ *: choices routerev -> req **: k -> next $
  where
    for (path, fn) in choices =>
      if (match = req.path `_issameas` path) =>
        k.update $ snd match
        yield    $ callprop fn req **: k
    req.abort 404


#: Route between multiple other routers as if they were subdirectories::
#:
#:   r.dir
#:     '/dir1/', r.file
#:       '/file1', handler1  #=> /dir1/file1
#:       '/file2', handler2  #=> /dir1/file2
#:     '/', r.file
#:       '/file3', handler3  #=> /file3
#:
#: Directory names may contain fields, just like file names.
#:
#: dir :: Router str
#:
dir = pathrouter no_bare: True $ *: choices routerev -> req **: k -> next $
  where
    for (path, fn) in choices =>
      if (match = req.path `_issubpathof` path) =>
        req.parent += req.path !! slice None (fst match)
        req.path    = req.path !! slice (fst match) None
        k.update $ snd match
        yield    $ callprop fn req **: k
    req.abort 404


#: Route on HTTP `Host` header. A handler matches iff `Host` is a non-strict
#: subdomain of a mask. An empty string matches everything.
#:
#: host :: Router str
#:
host = *: choices -> req **: k -> next $
  where
    for (host, fn) in choices =>
      if req.headers.get 'Host' `_issubdomainof` host =>
        yield $ callprop fn req **: k
    req.abort 404


#: Methods added to `Request` objects since they require fields only available in it.
#:
#: No parameters.
#:
ContextAware = subclass object where
  #: The name of the route this request was handed down to.
  #:
  #: handler :: str
  #:
  handler = ~> raise NotImplementedError

  #: Get the URL that points to a route named `n`.
  #: Paths that start with a dot are relative to the current context, similar
  #: to Python relative imports.
  #:
  #: url_for :: str ** -> str
  #:
  url_for = n **: args ~> raise NotImplementedError
