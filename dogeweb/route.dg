import '/re'
import '/functools'
import '/collections'


#: Syntax for wildcards.
#:
#: WILDCARDRE :: Regex
#:
WILDCARDRE = re.compile r'<(?:([\w_]+):)?([\w_]+)>'


#: The wild cards available for use in path routes. The first item
#: is the regex to use; the second is a function that parses the result.
#:
#: wildcards :: dict str (str, (str -> object))
#:
wildcards = dict'
  None,   ('[^/]+', str)
  'str',  ('[^/]+', str)
  'path', ('.+',    str)
  'int',  ('\d+',   int)


#: Given a path route, convert it into a regex that only matches appropriate requests.
#: Constructs of form `<type:name>` are converted into named groups; the exact contents
#: of these groups are determined by `wildcards`. Returns a tuple of group names,
#: a tuple of parsers, and a regex to match against.
#:
#: pathregex :: str -> (bool, tuple str, tuple (str -> a), Regex)
#:
pathregex = path directory ->
  names = list!
  funcs = list!

  if not (path.endswith '/') and directory =>
    raise $ ValueError $ '`{!r}` must end with a slash'.format path

  onwildcard = t name ->
    not $ t in wildcards => raise $ ValueError $ 'wildcard type `{!r}` not supported'.format t
    names.append name
    funcs.append $ wildcards !! t !! 1
    '(?P<{}>{})'.format name $ wildcards !! t !! 0

  cards = iter $ WILDCARDRE.split path
  # For some reason, a regex match is flattened into the list returned by `cards`
  # instead of staying a tuple. Ugh.
  regex = ''.join $ map (+)
    # Due to how iterators and `zip` work, `re.escape` will only receive
    # every third item; that is, only plain matches.
    map re.escape cards
    # `onwildcard`, on the other hand, will receive the other 2/3 of items.
    # If the path does not end with a wildcard, however, this iterator will be
    # one item shorter than necessary; that's why we pad it.
    map onwildcard cards cards +: ''

  directory, tuple names, tuple funcs, re.compile regex


#: Substitute values for wildcards in a path.
#:
#: concrete :: (dict str object) str -> str
#:
concrete = args path -> re.sub r'/+' '/' $ WILDCARDRE.sub (m -> str $ args !! m.group 2) path


#: Copy metadata (such as the name and the docstring) from one function to another.
#:
#: wraps :: (a -> b) (c -> d) -> (c -> d)
#:
wraps = f g ->
  # By default, `update_wrapper` override attributes defined on `g` with those
  # defined on `f` if their names clash.
  old, g.__dict__ = g.__dict__, f.__dict__.copy!
  g.__dict__.update old
  functools.update_wrapper g f updated: ()


#: Check whether a path matches the route. Return the length of the matched
#: component and an iterable of (name, value) pairs that describe groups.
#:
#: _issameas :: str (tuple str, tuple (str -> a), Regex) -> Maybe (int, iter (str, a))
#:
_issameas = path (d, ns, fs, regex) -> (m = regex.match path) and (d or m.end! == len path) => m.end! - 1,
  where for (name, f, value) in zip ns fs m.groups! => yield (name, f value)


#: Redirect to the same path, but with a slash appended.
#:
#: slash :: Request -> Response
#:
_slash = req **: _ -> req.redirect code: 301 $ req.fullpath + '/'


#: A factory that produces factories of functions that route requests based
#: on some constant value. For example:
#:
#:    router = _constrouter $ request **: args ~>
#:      ... iterate over (constant, handler) tuples in `@choices` ...
#:      ... call one of the handlers ...
#:
#:    handler = router
#:      'constant_value_1', request -> ...
#:      'constant_value_2', request -> ...
#:
#: Optionally, a string may be added between the constant and the handler;
#: that'd be the name of the route. New routes can be added through a first-class
#: function (the second argument is the name; it's mandatory):
#:
#:    handler.add 'constant_value_3' 'something' $ request -> ...
#:
#: For pure Python use, there's a curried version of `add` for use in decorators:
#:
#:    @handler.route('constant_value_4')
#:    def _(request):
#:        return ...
#:
_constrouter = __call__ ->
  __init__ = *: args ~>
    @ordered = list!  # [(const, name, handler)]
    @choices = dict!  # {const: (name, handler)}
    @routes  = dict!  # {name: (path, handler)}
    for t in args => @add *:
      if not $ t :: tuple => raise $ TypeError 'each argument must be a 2- or 3-tuple'
         len t == 2 => t !! 0, getattr (t !! 1) '__name__' '<?>', t !! 1
         len t == 3 => t
    None

  route = key  ~>  handler -> @add key (getattr handler '__name__' '<?>') handler
  add   = key name handler ~>
    @routes  !! name = '',   handler
    @choices !! key  = name, handler
    @ordered.append (key, name, handler)
    handler

  subclass object


#: Same as `_constrouter`, except the "constant values" in question are paths
#: with wildcards. In `choices`, they are stored as precompiled regex.
#:
#:   directory -- whether to require all paths to end with a slash and allow partial matches.
#:
_pathrouter = f directory: False -> subclass $ _constrouter f where
  add = path name handler ~>
    path   = re.sub r'/+' '/' path
    pathre = pathregex path directory

    @routes  !! name   = path, handler
    @choices !! pathre = name, handler
    @ordered.append (pathre, name, handler)

    path.endswith '/' and path != '/' =>
      bare   = path.rstrip '/'
      barere = pathregex bare False
      @choices !! barere = name, _slash
      @ordered.append (barere, name, _slash)
    handler


#: Route on HTTP `Host` header. A handler matches iff `Host` is a non-strict
#: subdomain of a mask. An empty string matches everything.
host = _constrouter $ (req:_) **: k ~>
  # NOTE the reason the first argument is named wierdly is to avoid clashes with
  #   keyword argument names. Since Python does not allow patterns as arguments,
  #   it will be named `<pattern:0>` by dg.
  host = req.headers.get 'Host' ''
  while True =>
    domain, _, _ = host.rpartition ':'
    if host   in @choices => result = (@choices !! host   !! 1)   req **: k
       domain in @choices => result = (@choices !! domain !! 1) req **: k
       not host           => req.abort 404
       otherwise          =>
         _, _, host = host.partition '.'
         continue!
    break!
  result


#: Allow upgrading to different protocols.
#: Uses HTTP `Upgrade` to choose between functions. `http` is the default.
upgrade = _constrouter $ (req:_) **: k ~>
  _, handler = @choices.get (str.lower $ req.headers.get 'Upgrade' 'http') (None, None)
  if handler   => handler req **: k
     otherwise => req.abort 505


#: Route on HTTP `Accept`.
accept = _constrouter $ (req:_) **: k ~>
  key = max @choices key: req.accept.mime.__getitem__
  (@choices !! key !! 0) req **: k


#: Route on HTTP method. Method names are uppercase.
#: `HEAD` is routed to `GET` unless redefined.
method = _constrouter $ (req:_) **: k ~>
  _, handler = @choices.get req.method (None, None)
  if handler   => handler req **: k
     otherwise => req.abort 405


#: Reject non-GET/HEAD requests.
#:
#: get :: (a -> b) -> (a -> b)
#:
get = f -> wraps f $ (req:_) **: k -> if
  req.method == 'GET' => f req **: k
  otherwise => req.abort 405


#: Route on HTTP path. If a request was made to `/something` and a route was found
#: that matches `/something/`, a redirect is issued.
path = _pathrouter $ (req:_) **: k ~> next $
  where
    for (path, _, fn) in @ordered =>
      if (match = req.path `_issameas` path) =>
        k.update $ snd match
        yield    $ fn req **: k
    req.abort 404


#: Route between multiple other routers as if they were subdirectories::
#:
#:   r.dir
#:     '/dir1/', r.file
#:       '/file1', handler1  #=> /dir1/file1
#:       '/file2', handler2  #=> /dir1/file2
#:     '/', r.file
#:       '/file3', handler3  #=> /file3
#:
#: Directory names may contain fields, just like file names.
#:
dir = _pathrouter directory: True $ (req:_) **: k ~> next $
  where
    for (path, name, fn) in @ordered =>
      if (match = req.path `_issameas` path) =>
        req.modroute.append fn
        req.modname .append $ name
        req.modpath .append $ req.path !! slice None (fst match)
        req.path            = req.path !! slice (fst match) None
        k.update $ snd match
        yield    $ fn req **: k
    req.abort 404


ContextAware = subclass object where
  #: Methods added to `Request` objects since they require fields only available in it.
  #:
  #: modpath  :: [str]     -- parts of `path` sliced off by `dir`.
  #: modroute :: [Handler] -- functions that correspond to these parts.
  #: modname  :: [str]     -- names of these functions.
  #:
  __init__ = *: a **: k ~>
    (super ContextAware self).__init__ *: a **: k
    @modpath  = list' ''
    @modroute = list' @handler
    @modname  = list' '<root>'
    None

  #: The requested path relative to `/`, not the current module.
  #:
  #: fullpath :: str
  #:
  fullpath = ~> @parent + @path

  #: Path to the current module.
  #:
  #: parent :: str
  #:
  parent = ~> ''.join @modpath

  #: Get the URL that points to a route named `n`.
  #: Paths that start with a dot are relative to the current context, similar
  #: to Python relative imports.
  #:
  #: url_for :: str ** -> str
  #:
  url_for = __name **: args ~>
    name   = __name.split '.'
    parent = 1
    while name !! 0 == '' =>
      name.pop 0
      parent -= 1

    xs = list (zip @modpath @modroute @modname) !! slice None (parent or None)
    not xs   => raise $ ValueError 'relative name out of bounds'
    not name => raise $ ValueError 'no route name'

    for n in name =>
      _, fn, m = xs !! -1
      except err => xs.append (fn.routes !! n !! 0, fn.routes !! n !! 1, n)
             err :: AttributeError => raise $ TypeError  $ '`{!r}` is not a namespace'.format m
             err :: KeyError       => raise $ ValueError $ '`{!r}` does not exist'.format n
    concrete args $ ''.join $ map fst xs
