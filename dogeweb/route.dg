import '/re'
import '/itertools'


#: Syntax for wildcards.
#:
#: WILDCARDRE :: Regex
#:
WILDCARDRE = re.compile r'<([\w_]+):([\w_]+)>'


#: The wild cards available for use in path routes. The first item
#: is the regex to use; the second is a function that parses the result.
#:
#: wildcards :: dict str (str, (str -> object))
#:
wildcards = dict'
  'str',  ('[^/]+', str)
  'path', ('.+',    str)
  'int',  ('\d+',   int)


#: Given a path route, convert it into a regex that only matches appropriate requests.
#: Constructs of form `<type:name>` are converted into named groups; the exact contents
#: of these groups are determined by `wildcards`. The other returned object
#: is a dict that maps field names to functions that parse their contents.
#:
#: pathregex :: str -> (dict str (str -> object), Regex)
#:
pathregex = path ->
  fnmap = dict!
  cards = WILDCARDRE.split path
  # For some reason, a regex match is flattened into the list returned by `cards`
  # instead of staying a tuple. Ugh.
  plain = cards !! slice 0 None 3
  types = cards !! slice 1 None 3
  names = cards !! slice 2 None 3

  onwildcard = wcid name -> if
    name in fnmap     => raise $ ValueError $ '{!r} contains repeating names'.format path
    wcid in wildcards =>
      fnmap !! name = wildcards !! wcid !! 1
      '(?P<{}>{})'.format name $ wildcards !! wcid !! 0
    otherwise => raise $ ValueError $ 'wildcard type {!r} not supported'.format wcid

  fnmap, re.compile $ ''.join $ map ''.join $ itertools.zip_longest fillvalue: ''
    map re.escape  plain
    map onwildcard types names


#: Substitute values for wildcards in a path.
#:
#: concrete :: (dict str object) str -> str
#:
concrete = args path -> WILDCARDRE.sub (m -> str $ args !! m.group 2) path


#: Mark a function as a router. Unlike endpoints, routers accept any method.
#:
#: router :: a -> a
#:
router = fn ->
  fn.router = True
  fn


#: Given a function that decides between multiple routes based on the requested path,
#: create one that
#:
#:   1. Allows for wildcards in these paths; e.g. `/<str:board>/<int:post>/`
#:      would match both `/b/1/` and `/s/100/`.
#:
#:   2. Allows for route names; in addition to `(path, handler)` tuples, it can accept
#:      `(path, name, handler)` tuples. These names could then be used to construct
#:      an URL without hardcoding the routes themselves.
#:
#:   3. For each route that ends with a slash creates one that does not, but redirects
#:      to the former. (e.g. if there's a route for `/something/`, `/something`
#:      would redirect there.)
#:
#: pathrouter :: (Router (dict str (str -> object), Regex)) (Optional bool) -> Router str
#:
pathrouter = f no_bare: False -> *: xs ->
  routemap = dict!
  routerev = dict!
  router   = f routerev: routerev *:
    where for q in xs =>
      data, name, h = if
        len q > 2 => q !! 0, q !! 1, q !! 2
        otherwise => q !! 0, None,   q !! 1
      name = name or getattr h '__name__' None

      data = re.sub r'/+' '/' data
      bare = '/' + data.strip '/'

      if data == bare and bare != '/' and no_bare =>
        raise $ ValueError $ '{!r} must end with a slash'.format data

      name =>
        routemap !! name = data, h
        routerev !! h    = name

      data_re = pathregex data
      bare_re = pathregex bare

      if data == bare => yield (data_re, h)
         otherwise    =>
           yield (data_re, h)
           yield (bare_re, **: _ ~> @redirect $ @fullpath + '/')
  router.routemap = routemap
  router.routerev = routerev
  router


#: Given a function that routes between multiple handler functions,
#: allow it to accept properties, too. Also, mark it as a router.
#:
#: proprouter :: Router a -> Router a
#:
proprouter = fn -> *: choices **: k ->
  choices = list
    where for (*xs, h) in choices => if
      h :: property => yield $ tuple xs + (_methodcheck h.fget,)
      otherwise     => yield $ tuple xs + (_methodcheck h,)
  router $ fn *: choices **: k


#: Make the function check whether the method is GET or there was a `method` router
#: somewhere along the path. Raise HTTP 405 otherwise.
#:
#: _methodcheck :: (Request * ** -> a) -> Request * ** -> a
#:
_methodcheck = fn -> if
  hasattr fn 'router' => fn  # Only endpoints need to check that.
  otherwise => *: a **: k ~> if
    @_nomethodcheck   => fn self *: a **: k
    @method == 'GET'  => fn self *: a **: k
    @method == 'HEAD' => fn self *: a **: k
    otherwise         => @abort 405


#: Check whether a requested `Host` is a subdomain of another.
#:
#: _issubdomainof :: str str -> bool
#:
_issubdomainof = host mask -> mask == host or host.endswith ('.' + mask)


#: Check whether a path is a subpath of another one. Return the length
#: of the matched component and a dictionary of groups.
#:
#: _issubpathof :: str (dict str (str -> object), Regex) -> Maybe (int, dict str object)
#:
_issubpathof = path (fns, regex) -> (m = regex.match path) => m.end! - 1, dict
  where for (name, value) in m.groupdict!.items! =>
    yield (name, (fns !! name) value)


#: Check whether a path matches the route exactly. Return value is the same
#: as for `_issubpathof`.
#:
#: _issameas :: str (dict str (str -> object), Regex) -> Maybe (int, dict str object)
#:
_issameas = path (fns, regex) -> (m = regex.match path) and m.end! == len path => m.end!,
  where for (name, value) in m.groupdict!.items! =>
    yield (name, (fns !! name) value)


#: Allow upgrading to different protocols. Implements HTTP `Upgrade`.
#:
#: upgrade :: Router str
#:
upgrade = proprouter $ *: choices -> req **: k -> next $
  where
    up = req.headers.get 'Upgrade' 'http'
    for (protocol, fn) in choices => if protocol == up =>
      yield $ fn req **: k
    req.abort 505


#: Route on HTTP `Accept`.
#:
#: accept :: Router str
#:
accept = proprouter $ *: choices -> req **: k ->
  xs = map ((i, (x, h)) -> (req.accept.mime !! x, -i, h)) $ enumerate choices
  fn = max xs !! 2
  fn req **: k


#: Route on HTTP method. Method names are uppercase.
#: `HEAD` is routed to `GET` unless redefined.
#:
#: method :: Router str
#:
method = proprouter $ *: choices -> req **: k -> next $
  where
    req._nomethodcheck = True
    for (method, fn) in choices =>
      if method == req.method or (req.method == 'HEAD' and method == 'GET') =>
        yield $ fn req **: k
    req.abort 405


#: Route on HTTP path. If a request was made to `/something` and a route was found
#: that matches `/something/`, a redirect is issued.
#:
#: file :: Router str
#:
file = proprouter $ pathrouter $ *: choices routerev -> req **: k -> next $
  where
    for (path, fn) in choices =>
      if (match = req.path `_issameas` path) =>
        k.update $ snd match
        yield    $ fn req **: k
    req.abort 404


#: Route between multiple other routers as if they were subdirectories::
#:
#:   r.dir
#:     '/dir1/', r.file
#:       '/file1', handler1  #=> /dir1/file1
#:       '/file2', handler2  #=> /dir1/file2
#:     '/', r.file
#:       '/file3', handler3  #=> /file3
#:
#: Directory names may contain fields, just like file names.
#:
#: dir :: Router str
#:
dir = proprouter $ pathrouter no_bare: True $ *: choices routerev -> req **: k -> next $
  where
    for (path, fn) in choices =>
      if (match = req.path `_issubpathof` path) =>
        req.modroute.append fn
        req.modname .append $ routerev.get fn None
        req.modpath .append $ req.path !! slice None (fst match)
        req.path            = req.path !! slice (fst match) None
        k.update $ snd match
        yield    $ fn req **: k
    req.abort 404


#: Route on HTTP `Host` header. A handler matches iff `Host` is a non-strict
#: subdomain of a mask. An empty string matches everything.
#:
#: host :: Router str
#:
host = proprouter $ *: choices -> req **: k -> next $
  where
    for (host, fn) in choices =>
      if req.headers.get 'Host' '' `_issubdomainof` host =>
        yield $ fn req **: k
    req.abort 404


ContextAware = subclass object where
  #: Methods added to `Request` objects since they require fields only available in it.
  #:
  #: modpath  :: [str]     -- parts of `path` sliced off by `dir`.
  #: modroute :: [Handler] -- functions that correspond to these parts.
  #: modname  :: [str]     -- names of these functions.
  #:
  __init__ = *: a **: k ~>
    @modpath  = list!
    @modroute = list!
    @modname  = list!
    # If this is set to `True`, `_methodcheck` does nothing.
    @_nomethodcheck = False
    (super ContextAware self).__init__ *: a **: k

  #: The requested path relative to `/`, not the current module.
  #:
  #: fullpath :: str
  #:
  fullpath = ~> @parent + @path

  #: Path to the current module.
  #:
  #: parent :: str
  #:
  parent = ~> ''.join @modpath

  #: Get the URL that points to a route named `n`.
  #: Paths that start with a dot are relative to the current context, similar
  #: to Python relative imports.
  #:
  #: url_for :: str ** -> str
  #:
  url_for = name **: args ~>
    parent = 0
    while name.startswith '.' =>
      name  !!= slice 1 None
      parent += 1

    xs = list $ zip @modpath @modroute
    # This allows absolute references, e.g. `url_for "static"`.
    xs.insert 0 ('', @handler)
    # On absolute imports, leave the root handler only.
    # On relative imports, leave everything but the last `parent - 1` entries.
    xs !!= slice None (1 - parent or None)
    not xs => raise $ ValueError 'relative import out of bounds'

    fn = xs !! -1 !! 1
    for n in name.split '.' =>
      not $ hasattr fn 'routemap' => raise $ TypeError 'module does not support namespacing'
      not $ n in fn.routemap      => raise $ ValueError $ 'route {!r} does not exist'.format n
      xs.append (path, fn = fn.routemap !! n)
    concrete args $ ''.join $ map fst xs
