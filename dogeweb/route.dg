import '/re'
import '/inspect'
import '/functools'
import '/itertools'


#: Syntax for wildcards.
#:
#: WILDCARDRE :: Regex
#:
WILDCARDRE = re.compile r'<(?:([\w_]+):)?([\w_]+)>'


#: The wild cards available for use in path routes. The first item
#: is the regex to use; the second is a function that parses the result.
#:
#: wildcards :: dict str (str, (str -> object))
#:
wildcards = dict'
  None,   ('[^/]+', str)
  'str',  ('[^/]+', str)
  'path', ('.+',    str)
  'int',  ('\d+',   int)


#: Given a path route, convert it into a regex that only matches appropriate requests.
#: Constructs of form `<type:name>` are converted into named groups; the exact contents
#: of these groups are determined by `wildcards`. The other returned object
#: is a dict that maps field names to functions that parse their contents.
#:
#: pathregex :: str -> (dict str (str -> object), Regex)
#:
pathregex = path ->
  fnmap = dict!
  cards = WILDCARDRE.split path
  # For some reason, a regex match is flattened into the list returned by `cards`
  # instead of staying a tuple. Ugh.
  plain = cards !! slice 0 None 3
  types = cards !! slice 1 None 3
  names = cards !! slice 2 None 3

  onwildcard = wcid name -> if
    name in fnmap     => raise $ ValueError $ '{!r} contains repeating names'.format path
    wcid in wildcards =>
      fnmap !! name = wildcards !! wcid !! 1
      '(?P<{}>{})'.format name $ wildcards !! wcid !! 0
    otherwise => raise $ ValueError $ 'wildcard type {!r} not supported'.format wcid

  fnmap, re.compile $ ''.join $ map ''.join $ itertools.zip_longest fillvalue: ''
    map re.escape  plain
    map onwildcard types names


#: Substitute values for wildcards in a path.
#:
#: concrete :: (dict str object) str -> str
#:
concrete = args path -> re.sub r'/+' '/' $ WILDCARDRE.sub (m -> str $ args !! m.group 2) path


#: Given a function that decides between multiple routes based on the requested path,
#: create one that
#:
#:   1. Allows for wildcards in these paths; e.g. `/<str:board>/<int:post>/`
#:      would match both `/b/1/` and `/s/100/`.
#:
#:   2. Allows for route names; in addition to `(path, handler)` tuples, it can accept
#:      `(path, name, handler)` tuples. These names could then be used to construct
#:      an URL without hardcoding the routes themselves.
#:
#:   3. For each route that ends with a slash creates one that does not, but redirects
#:      to the former. (e.g. if there's a route for `/something/`, `/something`
#:      would redirect there.)
#:
#: pathrouter :: (Router (dict str (str -> object), Regex)) (Optional bool) -> Router str
#:
pathrouter = f no_bare: False -> *: xs ->
  routemap = dict!
  routerev = dict!
  router   = f routerev: routerev *:
    where for q in xs =>
      data, name, h = if
        len q > 2 => q !! 0, q !! 1, q !! 2
        otherwise => q !! 0, None,   q !! 1
      name = name or getattr h '__name__' None

      data = re.sub r'/+' '/' data
      bare = '/' + data.strip '/'

      if data == bare and bare != '/' and no_bare =>
        raise $ ValueError $ '{!r} must end with a slash'.format data

      name =>
        routemap !! name = data, h
        routerev !! h    = name

      data_re = pathregex data
      bare_re = pathregex bare

      if data == bare => yield (data_re, h)
         otherwise    =>
           yield (data_re, h)
           yield (bare_re, **: _ ~> @redirect $ @fullpath + '/')
  router.routemap = routemap
  router.routerev = routerev
  router


#: Given a function that accepts either
#:   a. some arguments and a handler function; or
#:   b. a variable amount of arguments, each of them a handler or a tuple that ends with one
#: and returns a handler, do the following stuff:
#:   a. allow these handlers to be properties, not functions;
#:   b. mark the returned function as a router that accepts any method;
#:   c. make the endpoints raise HTTP 405 on non-HEAD/GET requests.
#:
#: router :: T:(Either (... Handler -> Handler) (*(*object, Handler) -> Handler)) -> T
#:
router = fn ->
  __ARG_POSITIONAL = inspect.Parameter.POSITIONAL_ONLY, inspect.Parameter.POSITIONAL_OR_KEYWORD
  # First, determine which kind of a router we're dealing with. The assumption is that
  # `varargs` is always a list of tuples, and functions without varargs accept a single router,
  # which should be the last argument w/o a default value.
  params = list (inspect.signature fn).parameters.values!
  varary = any  $ map (x -> x.kind == x.VAR_POSITIONAL) params
  # Second, find the last positional argument without a default value.
  iparams = enumerate (reversed params) 1
  posargs = filter ((_, x) -> x.kind in __ARG_POSITIONAL and x.default is x.empty) iparams
  i = not varary => except
    err => len params - fst (next posargs)
    err :: StopIteration => raise $ AssertionError 'cannot locate a non-default positional arg'

  *: choices **: options ->
    g = if varary    => _dispatch_multiple fn (list choices) options
           otherwise => _dispatch_single   fn (list choices) options i
    g.router = True
    g


_dispatch_single = fn choices options i ->
  h = choices !! i
  h = choices !! i = if
    h :: property => _methodcheck h.fget
    otherwise     => _methodcheck h
  functools.update_wrapper (fn *: choices **: options) h


_dispatch_multiple = fn choices options ->
  funcs   = list!
  choices = list
    where for h in choices =>
      yield $ if
        h :: property => _methodcheck h.fget
        h :: tuple    =>
          *xs, h = h
          if h :: property => tuple xs + (_methodcheck h.fget,)
             otherwise     => tuple xs + (_methodcheck h,)
        otherwise => _methodcheck h
      funcs.append $ getattr h 'fget' h
  functools.update_wrapper updated: () (fn *: choices **: options) $ next (iter funcs) fn


#: Make the function check whether the method is GET or there was a `method` router
#: somewhere along the path. Raise HTTP 405 otherwise.
#:
#: _methodcheck :: (Request * ** -> a) -> Request * ** -> a
#:
_methodcheck = fn -> if
  hasattr fn 'router' => fn  # Only endpoints need to check that.
  otherwise => functools.update_wrapper wrapped: fn $ *: a **: k ~> if
    @_nomethodcheck   => fn self *: a **: k
    @method == 'GET'  => fn self *: a **: k
    @method == 'HEAD' => fn self *: a **: k
    otherwise         => @abort 405


#: Check whether a requested `Host` is a subdomain of another.
#:
#: _issubdomainof :: str str -> bool
#:
_issubdomainof = host mask -> mask == host or host.endswith ('.' + mask)


#: Check whether a path is a subpath of another one. Return the length
#: of the matched component and a dictionary of groups.
#:
#: _issubpathof :: str (dict str (str -> object), Regex) -> Maybe (int, dict str object)
#:
_issubpathof = path (fns, regex) -> (m = regex.match path) => m.end! - 1, dict
  where for (name, value) in m.groupdict!.items! =>
    yield (name, (fns !! name) value)


#: Check whether a path matches the route exactly. Return value is the same
#: as for `_issubpathof`.
#:
#: _issameas :: str (dict str (str -> object), Regex) -> Maybe (int, dict str object)
#:
_issameas = path (fns, regex) -> (m = regex.match path) and m.end! == len path => m.end!,
  where for (name, value) in m.groupdict!.items! =>
    yield (name, (fns !! name) value)


#: Allow upgrading to different protocols. Implements HTTP `Upgrade`.
#:
#: upgrade :: Router str
#:
upgrade = router $ *: choices -> req **: k -> next $
  where
    up = req.headers.get 'Upgrade' 'http'
    for (protocol, fn) in choices => if protocol == up =>
      yield $ fn req **: k
    req.abort 505


#: Route on HTTP `Accept`.
#:
#: accept :: Router str
#:
accept = router $ *: choices -> req **: k ->
  fn = max choices key: ((x, _) -> req.accept.mime !! x) !! 1
  fn req **: k


#: Route on HTTP method. Method names are uppercase.
#: `HEAD` is routed to `GET` unless redefined.
#:
#: method :: Router str
#:
method = router $ *: choices -> req **: k -> next $
  where
    req._nomethodcheck = True
    for (method, fn) in choices =>
      if method == req.method or (req.method == 'HEAD' and method == 'GET') =>
        yield $ fn req **: k
    req.abort 405


#: Route on HTTP path. If a request was made to `/something` and a route was found
#: that matches `/something/`, a redirect is issued.
#:
#: file :: Router str
#:
file = router $ pathrouter $ *: choices routerev -> req **: k -> next $
  where
    for (path, fn) in choices =>
      if (match = req.path `_issameas` path) =>
        k.update $ snd match
        yield    $ fn req **: k
    req.abort 404


#: Route between multiple other routers as if they were subdirectories::
#:
#:   r.dir
#:     '/dir1/', r.file
#:       '/file1', handler1  #=> /dir1/file1
#:       '/file2', handler2  #=> /dir1/file2
#:     '/', r.file
#:       '/file3', handler3  #=> /file3
#:
#: Directory names may contain fields, just like file names.
#:
#: dir :: Router str
#:
dir = router $ pathrouter no_bare: True $ *: choices routerev -> req **: k -> next $
  where
    for (path, fn) in choices =>
      if (match = req.path `_issubpathof` path) =>
        req.modroute.append fn
        req.modname .append $ routerev.get fn None
        req.modpath .append $ req.path !! slice None (fst match)
        req.path            = req.path !! slice (fst match) None
        k.update $ snd match
        yield    $ fn req **: k
    req.abort 404


#: Route on HTTP `Host` header. A handler matches iff `Host` is a non-strict
#: subdomain of a mask. An empty string matches everything.
#:
#: host :: Router str
#:
host = router $ *: choices -> req **: k -> next $
  where
    this = req.headers.get 'Host' ''
    for (host, fn) in choices => if this `_issubdomainof` host =>
      yield $ fn req **: k
    req.abort 404


DecoRouter = subclass object where
  #: Transform a functional-style router into a decorator-style router.
  #:
  #: function  :: Router a -- the underlying functional router.
  #: pass_name :: bool -- whether the router accepts `(smth, name, function)` 3-tuples.
  #:
  __init__ = function pass_name ~>
    @function  = function
    @pass_name = pass_name
    @_args     = list!
    None

  #: Register a route.
  #:
  #: add_route :: a (Maybe str) Handler -> b
  #:
  add_route = smth name handler ~>
    @_args.append $ if
      @pass_name and name => smth, name, handler
      otherwise           => smth,       handler
    handler

  #: Register a route in decorator form. Useless in dg, useful in Python.
  #:
  #:   x = r.File()
  #:
  #:   @x.route('/')
  #:   def hello(request)
  #:       return 'Hello, World!'
  #:
  #: route :: a -> Handler -> b
  #:
  route = smth ~> bind @add_route smth None

  #: Return a function usable in applications.
  #:
  #: handler :: Handler
  #:
  handler = ~> @function *: @_args


Upgrade = bind DecoRouter upgrade False
Accept  = bind DecoRouter accept  False
Method  = bind DecoRouter method  False
File    = bind DecoRouter file    True
Dir     = bind DecoRouter dir     True
Host    = bind DecoRouter host    False


ContextAware = subclass object where
  #: Methods added to `Request` objects since they require fields only available in it.
  #:
  #: modpath  :: [str]     -- parts of `path` sliced off by `dir`.
  #: modroute :: [Handler] -- functions that correspond to these parts.
  #: modname  :: [str]     -- names of these functions.
  #:
  __init__ = *: a **: k ~>
    (super ContextAware self).__init__ *: a **: k
    @modpath  = list' ''
    @modroute = list' @handler
    @modname  = list' '<root>'
    # If this is set to `True`, `_methodcheck` does nothing.
    @_nomethodcheck = False
    None

  #: The requested path relative to `/`, not the current module.
  #:
  #: fullpath :: str
  #:
  fullpath = ~> @parent + @path

  #: Path to the current module.
  #:
  #: parent :: str
  #:
  parent = ~> ''.join @modpath

  #: Get the URL that points to a route named `n`.
  #: Paths that start with a dot are relative to the current context, similar
  #: to Python relative imports.
  #:
  #: url_for :: str ** -> str
  #:
  url_for = __name **: args ~>
    name   = __name.split '.'
    parent = 1
    while name !! 0 == '' =>
      name.pop 0
      parent -= 1

    xs = list (zip @modpath @modroute @modname) !! slice None (parent or None)
    not xs   => raise $ ValueError 'relative name out of bounds'
    not name => raise $ ValueError 'no route name'

    for n in name =>
      _, fn, m = xs !! -1
      except err => xs.append (fn.routemap !! n !! 0, fn.routemap !! n !! 1, n)
             err :: AttributeError => raise $ TypeError  $ 'route {!r} is not a namespace'.format m
             err :: KeyError       => raise $ ValueError $ 'route {!r} does not exist'.format n
    concrete args $ ''.join $ map fst xs
