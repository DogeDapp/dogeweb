import '/os'
import '/json'
import '/asyncio'
import '/mimetypes'
import '/http/client/responses'

import 'struct'


#: Convert an arbitrary object into a response.
#:
#: Currently supported are strings (simple HTML responses in UTF-8),
#: actual `Response`s, and `(code, responsifyable)` tuples, as well as coroutines
#: that return them.
#:
#: responsify :: object -> coroutine Response
#:
responsify = asyncio.coroutine $ smth -> if
  smth :: Response => smth
  smth :: str      => Response 200 dict! $ smth.encode 'utf-8'
  smth :: tuple    =>
    r = yield from $ responsify $ snd smth
    r.code = fst smth
    r
  otherwise => yield from $ responsify $ yield from smth


#: Create a json response. Unlike `json.dumps`, this specifies proper `Content-Type`.
#:
#: jsonify :: object -> Response
#:
jsonify = smth -> Response 200
  dict' ('Content-Type', 'application/json; charset=utf-8')
  (json.dumps smth).encode 'utf-8'


Abort = subclass Exception where
  #: The exception raised on HTTP errors.
  #:
  #: ???
  #:
  __init__ = @code @description: '' @headers: dict! @flags: 0 ~>
    (super Abort self).__init__ @description

  name = ~> responses.get @code 'Unknown Error'


Writer = subclass object where
  __init__ = @transport ~>
  # This method provides compatibility with asyncio transports.
  # It shouldn't do anything; instead, `write` should drain on every call.
  drain = asyncio.coroutine $ self -> None
  close = asyncio.coroutine $ self -> None


SimpleWriter = subclass Writer where
  write = data ~>
    @transport.write data
    @transport.drain!


ChunkWriter = subclass Writer where
  write = data ~>
    data =>
      ln = hex $ len data
      ln = ln.encode 'ascii'
      ln = ln.lstrip b'0x'
      @transport.write $ ln + b'\r\n' + data + b'\r\n'
      @transport.drain!

  close = self ->
    @transport.write b'0\r\n\r\n'
    @transport.drain!


Response = subclass object where
  __init__ = code headers data ~>
    @code    = code
    @headers = headers
    @data    = data
    @headers = struct.Headers @defheaders
    @headers.replace headers
    None

  #: Headers that are required for all responses, such as `Content-Type` and `Content-Length`.
  #:
  #: defheaders :: dict str str
  #:
  defheaders = ~> dict'
    'Content-Type',   'text/html; charset=utf-8'
    'Content-Length', str $ len @data
    # NOTE this should be replaced with `'Transfer-Encoding', 'chunked'` if
    #      content-length could not be calculated.

  #: Write the whole response into an object.
  #:
  #: write_all :: IOBase (int, int) -> coroutine a
  #:
  write_all = asyncio.coroutine $ writer version ~>
    status  = 'HTTP/%s.%s %s %s\r\n' % (version + (@code, responses.get @code 'Unknown'))
    headers = '\r\n'.join $ map ': '.join @headers.items
    writer.write $ (status + headers + '\r\n\r\n').encode 'latin-1'

    chunked = @headers.get 'Transfer-Encoding' == 'chunked'
    writer  = if
      chunked   => ChunkWriter  writer
      otherwise => SimpleWriter writer

    yield from $ @write_body writer.write
    yield from $ writer.close!

  #: Call a function with chunks that comprise the body of this response.
  #:
  #: write_body :: (bytes -> coroutine a) -> coroutine a
  #:
  write_body = cb ~> cb @data


FileResponse = subclass Response where
  #: A `Response` that sends data from a file.
  #:
  #: path    :: str -- the file to read from.
  #: bufsize :: int -- how much data to read every syscall.
  #:
  __init__ = code path headers bufsize: 65536 ~>
    @path    = path
    @bufsize = bufsize
    Response.__init__ self code headers b''

  #: IO-specific headers. `Content-Length` is determined via `stat`.
  #:
  #: defheaders :: dict str str
  #:
  defheaders = ~> xs where
    xs = dict' $ except
      err => 'Content-Length', str (os.stat @path).st_size
      err :: OSError => abort 404

  #: Send the contents of a file object.
  #:
  #: write_body :: (bytes -> coroutine a) -> coroutine a
  #:
  write_body = asyncio.coroutine $ cb ~>
    # TODO make this async?
    with fd = open @path 'rb' => while (b = fd.read @bufsize) => yield from $ cb b


#: Stop the handler, return an error message.
#:
#: abort :: int (Optional str) (Optional (dict str str)) -> a
#:
abort = code info: '' headers: dict! -> raise $ Abort code info headers


#: Issue a 302 Found. The client is redirected to a new URL.
#:
#: redirect :: str (Optional str) -> a
#:
redirect = path description: '' -> raise $ Abort 302 description $ dict' location: path


#: Serve a single static file.
#:
#: static :: str (Optional bool) (Optional (dict str str)) -> Response
#:
static = path attachment: True headers: dict! ->
  mime = fst $ mimetypes.guess_type path strict: False
  attachment =>
    # TODO specify `filename`.
    headers.setdefault 'Content-Disposition' 'attachment'
  headers.setdefault 'Content-Type' $ mime or 'application/octet-stream'
  FileResponse 200 path headers
