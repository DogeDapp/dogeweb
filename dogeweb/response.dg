import '/os'
import '/json'
import '/asyncio'
import '/mimetypes'
import '/http/client/responses'

import '/aiohttp'
import '/aiohttp/websocket' qualified

import 'struct'


#: Convert an arbitrary object into a response.
#:
#: Currently supported are strings (simple HTML responses in UTF-8),
#: actual `Response`s, and `(code, responsifyable)` tuples, as well as coroutines
#: that return them.
#:
#: responsify :: object -> coroutine Response
#:
responsify = asyncio.coroutine $ smth -> if
  smth :: Response => smth
  smth :: str      => Response 200 dict! $ smth.encode 'utf-8'
  smth :: tuple    =>
    r = yield from $ responsify $ snd smth
    r.code = fst smth
    r
  otherwise => yield from $ responsify $ yield from smth


#: Create a json response. Unlike `json.dumps`, this specifies proper `Content-Type`.
#:
#: jsonify :: object -> Response
#:
jsonify = smth -> Response 200
  dict' ('Content-Type', 'application/json; charset=utf-8')
  (json.dumps smth).encode 'utf-8'


Abort = subclass Exception where
  #: The exception raised on HTTP errors.
  #:
  #: ???
  #:
  __init__ = @code @description: '' @headers: dict! @flags: 0 ~>
    (super Abort self).__init__ @description

  name = ~> responses.get @code 'Unknown Error'


Response = subclass object where
  __init__ = code headers data ~>
    @code    = code
    @headers = headers
    @data    = data
    @headers = struct.Headers @defheaders
    @headers.replace headers
    None

  #: Release all resources attached to this response.
  #:
  #: close :: a
  #:
  close = ~> None

  #: Write the data from this response into an object.
  #:
  #: write_to :: IOBase -> coroutine a
  #:
  write_to = asyncio.coroutine $ response ~> response.write @data

  #: Headers that are required for all responses, such as `Content-Type` and `Content-Length`.
  #:
  #: defheaders :: dict str str
  #:
  defheaders = ~> dict'
    'Content-Type',   'text/html; charset=utf-8'
    'Content-Length', str $ len @data
    # NOTE this should be replaced with `'Transfer-Encoding', 'chunked'` if
    #      content-length could not be calculated.


IOResponse = subclass Response where
  #: A `Response` that sends data from a file.
  #:
  #: fileobj :: IOBase -- the file to read from.
  #: bufsize :: int    -- how much data to read every syscall.
  #:
  __init__ = code fileobj headers bufsize: 16384 ~>
    @fileobj = fileobj
    @bufsize = bufsize
    Response.__init__ self code headers b''

  #: Close the file object, if applicable.
  #:
  #: close :: a
  #:
  close = ~> except
    err => @fileobj.close!
    err :: IOError        =>
    err :: AttributeError =>

  #: Send the contents of a file object.
  #:
  #: write_to :: IOBase -> coroutine a
  #:
  write_to = asyncio.coroutine $ response ~>
    # TODO make this async?
    while (b = @fileobj.read @bufsize) => response.write b

  #: IO-specific headers. `Content-Length` is determined via `stat`; if not possible,
  #: `Transfer-Encoding: chunked` is used instead.
  #:
  #: defheaders :: dict str str
  #:
  defheaders = ~> xs where
    xs = dict' $ except
      err => 'Content-Length', str (os.stat @fileobj.fileno!).st_size
      err :: IOError        => 'Transfer-Encoding', 'chunked'
      err :: AttributeError => 'Transfer-Encoding', 'chunked'


#: Stop the handler, return an error message.
#:
#: abort :: int (Optional str) (Optional (dict str str)) -> a
#:
abort = code info: '' headers: dict! -> raise $ Abort code info headers


#: Issue a 302 Found. The client is redirected to a new URL.
#:
#: redirect :: str (Optional str) -> a
#:
redirect = path description: '' -> raise $ Abort 302 description $ dict' location: path


#: Serve a single static file.
#:
#: static :: str (Optional bool) (Optional (dict str str)) -> Response
#:
static = path attachment: True headers: dict! -> except
  # TODO make this crap asynchronous.
  err => fd = open path 'rb'
  err :: IOError => abort 404
  err is None    =>
    mime = fst $ mimetypes.guess_type path strict: False
    attachment =>
      # TODO specify `filename`.
      headers.setdefault 'Content-Disposition' 'attachment'
    headers.setdefault 'Content-Type' $ mime or 'application/octet-stream'
    IOResponse 200 fd headers
