import '/os'
import '/json'
import '/asyncio'
import '/mimetypes'

import 'http'
import 'struct'


#: Convert an arbitrary object into a response.
#:
#: Currently supported are strings and bytes (simple HTML responses in UTF-8), actual
#: `Response`s, and `(code, [headers,] responsifyable)` tuples, as well as coroutines
#: that return them.
#:
#: responsify :: object -> coroutine Response
#:
responsify = asyncio.coroutine $ smth -> if
  smth :: Response => smth
  smth :: bytes    => Response 200 () smth
  smth :: str      => Response 200 () $ smth.encode 'utf-8'
  smth :: tuple    =>
    code, *headers, smth = smth
    r = yield from $ responsify $ smth
    r.code = code
    exhaust $ map r.headers.replace headers
    r
  otherwise => yield from $ responsify $ yield from smth


#: Create a json response. Unlike `json.dumps`, this specifies proper `Content-Type`.
#:
#: jsonify :: object -> Response
#:
jsonify = smth -> Response 200
  ('Content-Type', 'application/json; charset=utf-8'), ('Cache-Control', 'no-cache, no-store, must-revalidate')
  (json.dumps smth).encode 'utf-8'


Abort = subclass Exception where
  #: The exception raised on HTTP errors.
  #:
  #: ???
  #:
  __init__ = @code @description: '' @headers: () ~>
    @headers = struct.Headers @headers
    (super Abort self).__init__ @description

  name = ~> http.responses.get @code 'Unknown Error'


Response = subclass object where
  __init__ = code headers data ~>
    @code    = code
    @headers = headers
    @data    = list' data
    @headers = struct.Headers @defheaders
    @headers.replace headers
    None

  #: Headers that are required for all responses, such as `Content-Type` and `Content-Length`.
  #:
  #: defheaders :: dict str str
  #:
  defheaders = ~> list'
    'Content-Type',   'text/html; charset=utf-8'
    'Content-Length', str $ sum $ map len @data
    # NOTE this should be replaced with `'Transfer-Encoding', 'chunked'` if
    #      content-length could not be calculated.

  #: Talk to the client in some other protocol, if applicable.
  #:
  #: communicate :: StreamReader StreamWriter -> coroutine a
  #:
  communicate = asyncio.coroutine $ reader writer ~> None


FileResponse = subclass Response where
  #: A `Response` that sends data from a file.
  #:
  #: path    :: str -- the file to read from.
  #: bufsize :: int -- how much data to read every syscall.
  #:
  __init__ = code path headers bufsize: 65536 ~>
    @path    = path
    @bufsize = bufsize
    Response.__init__ self code headers b''

  #: IO-specific headers. `Content-Length` is determined via `stat`.
  #:
  #: defheaders :: dict str str
  #:
  defheaders = ~> list'
    except err => 'Content-Length', str (os.stat @path).st_size
           err :: OSError => abort 404

  #: The contents of a file object.
  #:
  #: data :: iter bytes
  #:
  data = property
    self   -> with fd = open @path 'rb' => while (b = fd.read @bufsize) => yield b
    self _ -> # Ignore `@data = ...` from `Response.__init__`.


#: Stop the handler, return an error message.
#:
#: abort :: int (Optional str) (Optional (dict str str)) -> a
#:
abort = code info: '' headers: () -> raise $ Abort code info headers


#: Issue a 303 See Other. The client is redirected to a new URL.
#:
#: redirect :: str (Optional str) (Optional int) (Optional (dict str str)) -> a
#:
redirect = path info: '' code: 303 headers: () ->
  exc = Abort code info headers
  exc.headers !! 'location' = path
  raise exc


#: Serve a single static file.
#:
#: static :: str (Optional bool) (Optional (dict str str)) -> Response
#:
static = path attachment: True headers: () ->
  mime    = fst $ mimetypes.guess_type path strict: False
  headers = struct.Headers headers
  attachment =>
    # TODO specify `filename`.
    headers.setdefault 'Content-Disposition' 'attachment'
  headers.setdefault 'Content-Type' $ mime or 'application/octet-stream'
  FileResponse 200 path headers
