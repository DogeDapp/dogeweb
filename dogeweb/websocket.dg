import '/asyncio'
import '/base64'
import '/random'
import '/struct'
import '/hashlib'
import '/itertools'

import 'route'
import 'response'


CONT, TEXT, DATA, _, _, _, _, _, CLOSE, PING, PONG, _, _, _, _, _ = range 16
SHORT = (1 << 16) - 1  # max. size of a frame with 2-byte length field (7-bit len = 126)
LONG  = (1 << 64) - 1  # max. size of a frame with 8-byte length field (7-bit len = 127)
GUID  = b'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'
# XXX ugly.
inH   = a b -> a in map str.strip (b.lower!.split ',')


Message = subclass object where
  # NOTE `tp` is assigned in `WebSocket.__next__`.
  is_ping  = ~> @tp == PING
  is_pong  = ~> @tp == PONG
  is_data  = ~> @tp == DATA
  is_text  = ~> @tp == TEXT
  is_close = ~> @tp == CLOSE


Message.Data = subclass Message bytes where
Message.Text = subclass Message str   where


WebSocket = subclass object where
  __init__ = @loop @reader @writer @client ~>
    # If `next_message` is interrupted by a control frame while waiting
    # for the next part of a continued data frame, this will contain
    # that partial data frame (while the control frame will be returned.)
    @cont = None
    None

  #: Receive a single message from the stream or cancel on disconnect,
  #: all while automatically responding to pings.
  #:
  #: self :: coroutine Message
  #:
  __iter__ = self ->
    while True =>
      code, data = except
        err => yield from @next_message
        err :: UnicodeDecodeError          => raise $ asyncio.CancelledError err
        err :: asyncio.IncompleteReadError => raise $ asyncio.CancelledError err

      msg = if code == TEXT  => Message.Text $ data.decode 'utf-8'
               code == CLOSE => Message.Data $ data !! slice 2 None
               otherwise     => Message.Data   data
      msg.tp = code

      if msg.is_ping  => yield from $ @pong msg
         msg.is_close => raise $ asyncio.CancelledError msg
         otherwise    => raise $ StopIteration msg

  next_message = ~>
    fin, code, data = @cont or yield from @next_frame
    while not fin =>
      fin, ctrl, part = yield from @next_frame
      fin and ctrl != CONT =>
        @cont = False, code, data
        raise $ StopIteration (ctrl, part)
      @cont = None
      data += part
    code, data

  next_frame = ~>
    h1, h2 = yield from $ @reader.readexactly 2
    fin  = h1 & 0x80 |> bool
    code = h1 & 0x0F
    mask = h2 & 0x80 |> bool
    size = h2 & 0x7F
    code > 0x7 and not fin => raise $ asyncio.IncompleteReadError 'fragmented control frame'

    size = if size == 126 => int.from_bytes (yield from $ @reader.readexactly 2) 'big'
              size == 127 => int.from_bytes (yield from $ @reader.readexactly 8) 'big'
              otherwise   => size
    mask = mask => yield from $ @reader.readexactly 4
    data =         yield from $ @reader.readexactly size

    fin, code, if mask      => bytes $ map (^) data $ itertools.cycle mask
                  otherwise => data

  send_frame = fin code data ~>
    ln   = len data
    fin  = bool fin     << 7
    mask = bool @client << 7
    head = if ln <= 125   => struct.pack '!BB'  (fin | code) (mask | ln)
              ln <= SHORT => struct.pack '!BBH' (fin | code) (mask | 126) ln
              ln <= LONG  => struct.pack '!BBQ' (fin | code) (mask | 127) ln
              otherwise   => raise $ ValueError 'frame too long (>= 4 GiB, somehow)'
    mask => mask = random.getrandbits 32 |>.to_bytes 4 'big'
    @writer.write $ head + if
      mask      => bytes $ map (^) (b'\0\0\0\0' + data) $ itertools.cycle mask
      otherwise => data
    @writer.drain!

  ping  = data ~> @send_frame True PING data
  pong  = data ~> @send_frame True PONG data
  data  = data ~> @send_frame True DATA data
  text  = data ~> @send_frame True TEXT $ data.encode 'utf-8'
  close = code: 1000 data: b'' ~>
    yield from $ @send_frame True CLOSE $ code.to_bytes 2 'big' + data
    raise ConnectionError

  #: Read frames from multiple websockets at once, return a (websocket, frame) pair
  #: every time a frame is received.
  #:
  #: mux :: WebSocket... -> coroutine (WebSocket, Message)
  #:
  mux = *: (socks:(self, *_)) ->
    socks = dict (where for s in socks => yield (asyncio.async loop: @loop $ iter s, s))

    PseudoCoroutine = subclass object where __iter__ = _ ->
      done, _ = yield from $ asyncio.wait socks loop: @loop return_when: asyncio.FIRST_COMPLETED
      done =>
        sock = socks.pop $ fst done
        socks !! asyncio.async loop: @loop (iter sock) = sock
        sock, yield from $ fst done
    PseudoCoroutine!


Response = subclass response.Response where
  #: A WebSocket handshake `Response`.
  #:
  #: key     :: str -- `Sec-WebSocket-Key` of the request.
  #: handler :: Reader Writer -> coroutine a
  #:
  __init__ = handler @key @req @kwargs ~>
    @handler = asyncio.coroutine handler
    @@__init__ 101 () b''

  #: WebSocket handshake headers.
  #:
  #: defheaders :: dict str str
  #:
  defheaders = ~> dict'
    'Upgrade',    'websocket'
    'Connection', 'upgrade'
    'Sec-WebSocket-Accept',
      (base64.b64encode (hashlib.sha1 $ @key.encode 'ascii' + GUID).digest!).decode 'ascii'

  #: Start a WebSocket session.
  #:
  #: communicate :: StreamReader StreamWriter -> coroutine a
  #:
  communicate = reader writer ~>
    @handler @req **: @kwargs $ WebSocket @req.loop reader writer False


#: Create a request handler that initiates a WebSocket connection
#:
#: endpoint :: (Request WebSocket -> coroutine a) -> (Request -> coroutine Response)
#:
endpoint = handler -> route.wraps handler $ **: k ~>
  if @method != 'GET' => @abort 405 headers: (dict allow: 'GET')
     not $ 'websocket' `inH` @headers.get 'Upgrade'    => @abort 400 'This is a websocket node.'
     not $ 'upgrade'   `inH` @headers.get 'Connection' => @abort 400 '`Connection: upgrade`?'

  ver = @headers.get 'Sec-WebSocket-Version'
  key = @headers.get 'Sec-WebSocket-Key'

  if not $ ver == '13' => @abort 400 'Unsupported WebSocket version.'
     not $ (except
       err => len (base64.b64decode key) == 16
       err :: Exception => False) => @abort 400 'WebSocket handshake error.'
  Response handler key self k


#: Do the same thing as `endpoint`, but with multiple connections.
#: The handler is called once `n` connections are available.
#:
#: aggregate :: int (Request WebSocket... -> coroutine a) -> (Request -> coroutine Response)
#:
aggregate = n handler ->
  # Ok, so differentiating between endpoints is hard. I give up.
  # We'll just assume "same path = same endpoint".
  datamap = dict!

  endpoint $ route.wraps handler $ __io **: k ~>
    # So the algorithm is this: we spawn a task that monitors a set of connections.
    # If its size reaches 0, the task exits. If it reaches `n`, the task calls
    # the handler. Meanwhile, the actual request-handling tasks add their connections
    # to the set, then wait until either the task exits or the connection is closed,
    # then remove their connection from the set. Simple.
    task, conns, event, stop = datamap.get @fullpath (None, None, None, None)
    task is None =>
      conns = set!
      event = asyncio.Event loop: @loop
      stop  = asyncio.Event loop: @loop
      task  = asyncio.async loop: @loop
        where except
          err     => while 0 < len conns < n => yield from event.wait!, event.clear!
          finally =>
            datamap.pop @fullpath None
            except
              inner => not err and conns => yield from $ handler self conns **: k
              inner :: ConnectionError        =>
              inner :: ConnectionResetError   =>
              inner :: asyncio.CancelledError =>
              finally => stop.set!
      datamap !! @fullpath = task, conns, event, stop

    conns.add __io
    event.set!
    except
      _ =>
        yield from stop.wait!
        yield from $ __io.close 1001
      finally =>
        conns.remove __io
        event.set!


#: Start a client-side WebSocket connection.
#:
#: client :: str StreamReader StreamWriter -> WebSocket
#:
client = path rd wr ->
  key = base64.b64encode $ bytes (where for _ in range 16 => yield $ random.randrange 256)
  wr.write $ b'GET ' + path.encode 'latin-1' + b' HTTP/1.1\r\n'
  wr.write $ b'Upgrade: websocket\r\n'
  wr.write $ b'Connection: upgrade\r\n'
  wr.write $ b'Sec-WebSocket-Version: 13\r\n'
  wr.write $ b'Sec-WebSocket-Key: ' + key +  b'\r\n'
  wr.write $ b'\r\n'

  header = yield from $ rd.readline!
  header != b'HTTP/1.1 101 Switching Protocols\r\n' => raise $ ConnectionError 'handshake failed'

  while True =>
    header = yield from $ rd.readline!
    header == b'\r\n' => break!
    n, val = header.split b' ' 1
    if n.lower! == b'sec-websocket-accept' =>
      chk = base64.b64decode val.strip!
      chk != (hashlib.sha1 $ key + GUID).digest! => raise $ ConnectionError 'key check error'

  WebSocket rd._loop rd wr True
