import '/asyncio'
import '/base64'
import '/random'
import '/hashlib'
import '/itertools'

import 'response'


Error = subclass Exception where
GUID  = b"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
CONT  = 0x0
TEXT  = 0x1
DATA  = 0x2
CLOSE = 0x8
PING  = 0x9
PONG  = 0xa
SHORT = 0xFFFF
LONG  = 0xFFFFFFFFFFFFFFFF
!=?   = a b -> not $ b.lower!.strip! in list (map str.strip $ a.lower!.split ',')


#: ???
#:
#: parse :: StreamReader -> coroutine Message
#:
parse = buf ->
  fin, code, *data = yield from $ parse_frame buf

  while not fin =>
    fin, cont, part = yield from $ parse_frame buf
    cont != CONT => raise $ Error 'unexpected opcode in continuation frame'
    data.append part
  data = b''.join data

  if code != CLOSE => Message code data None
     otherwise     =>
       code = data !! slice None 2
       rest = data !! slice 2 None
       Message CLOSE rest (int.from_bytes code 'big')


#: ???
#:
#: parse_frame :: StreamReader -> coroutine (int, int, bytes)
#:
parse_frame = buf ->
  head = yield from $ buf.readexactly 2
  head = int.from_bytes head 'big'

  # fin -- 0 if more frames from the same message follow.
  # rsv -- reserved fields, must be 0.
  fin    = (head & 0x8000) >> 15
  rsv    = (head & 0x7000) >> 12
  code   = (head & 0x0F00) >> 8
  masked = (head & 0x0080) >> 7
  length = (head & 0x007F)

  rsv => raise $ Error 'non-zero reserved value'
  code > 0x7 and not fin      => raise $ Error => 'fragmented control frame'
  code > 0x7 and length > 125 => raise $ Error => 'control frame payload length invalid'

  length = if
    length == 126 => int.from_bytes (yield from $ buf.readexactly 2) 'big'
    length == 127 => int.from_bytes (yield from $ buf.readexactly 8) 'big'
    otherwise     => length

  mask = itertools.cycle $ if
    masked    => yield from $ buf.readexactly 4
    otherwise => 0, 0, 0, 0

  fin, code, bytes $ map (^) mask $ if
    length    => yield from $ buf.readexactly length
    otherwise => b''


Message = subclass object where
  __new__ = tp data extra ~>
    self = if
      tp != TEXT => bytes.__new__ DataMessage data
      otherwise  => str.__new__   TextMessage $ except
        err => data.decode 'utf-8'
        err :: UnicodeDecodeError => raise $ asyncio.CancelledError er

    self.tp    = tp
    self.extra = extra
    self

  is_ping  = ~> @tp == PING
  is_pong  = ~> @tp == PONG
  is_data  = ~> @tp == DATA
  is_text  = ~> @tp == TEXT
  is_close = ~> @tp == CLOSE


DataMessage = subclass Message bytes where
TextMessage = subclass Message str   where


WebSocket = subclass object where
  __init__ = self @reader @writer ->
  __iter__ = self -> while True =>
    msg = except
      err => yield from $ parse @reader
      err :: asyncio.IncompleteReadError => raise asyncio.CancelledError
    if msg.is_ping  => yield from @pong
       msg.is_close => raise $ asyncio.CancelledError msg
       otherwise    => raise $ StopIteration msg

  _head    = code ln   ~> bytes (((code != CONT) << 7) | code, ln)
  _frame   = code data ~>
    ln = len data
    if ln <= 125   => @writer.write $ @_head code ln + data
       ln <= SHORT => @writer.write $ @_head code 126 + ln.to_bytes 2 'big' + data
       ln <= LONG  => @writer.write $ @_head code 127 + ln.to_bytes 8 'big' + data
       otherwise =>
         yield from $ @_frame code $ data !! slice None LONG
         yield from $ @_frame CONT $ data !! slice LONG None
    yield from @writer.drain!

  ping  = data ~> @_frame PING data
  pong  = data ~> @_frame PONG data
  data  = data ~> @_frame DATA data
  text  = data ~> @_frame TEXT $ data.encode 'utf-8'
  close = code: 1000 data: b'' ~>
    except err => yield from $ @_frame CLOSE $ code.to_bytes 2 'big' + data
           err :: ConnectionError =>
    raise $ asyncio.CancelledError 'closed from this side'


Response = subclass response.Response where
  #: A WebSocket handshake `Response`.
  #:
  #: key     :: str -- `Sec-WebSocket-Key` of the request.
  #: handler :: Reader Writer -> coroutine a
  #:
  __init__ = handler @key ~>
    @handler = asyncio.coroutine handler
    response.Response.__init__ self 101 dict! b''

  #: WebSocket handshake headers.
  #:
  #: defheaders :: dict str str
  #:
  defheaders = ~> dict'
    'Upgrade',    'websocket'
    'Connection', 'upgrade'
    'Sec-WebSocket-Accept',
      (base64.b64encode (hashlib.sha1 $ @key.encode 'ascii' + GUID).digest!).decode 'ascii'

  #: Start a WebSocket session.
  #:
  #: communicate :: StreamReader StreamWriter -> coroutine a
  #:
  communicate = reader writer ~> @handler $ WebSocket reader writer


ContextAware = subclass object where
  #: Create a WebSocket from this request.
  #:
  #: websocket :: (WebSocket -> coroutine a) -> Response
  #:
  websocket = handler ~>
    if @method != 'GET' => @abort 405 headers: (dict allow: 'GET')
       @headers.get 'Upgrade'    !=? 'websocket' => @abort 400 'This is a websocket node.'
       @headers.get 'Connection' !=? 'upgrade'   => @abort 400 '`Connection: upgrade`?'

    ver = @headers.get 'Sec-WebSocket-Version'
    key = @headers.get 'Sec-WebSocket-Key'

    if not $ ver == '13' => @abort 400 'Unsupported WebSocket version.'
       not $ (except
         err => len (base64.b64decode key) == 16
         err :: Exception => False) => @abort 400 'WebSocket handshake error.'
    Response handler key

  #: Create `n` WebSocket streams. The first stream is this request; the rest are
  #: those that connect to the same endpoint directly after this client. Only the first
  #: handler will get to manipulate these streams; the others will wait, then abort.
  #: The identifier is used to unambiguously differentiate between endpoints.
  #:
  #: websockets :: int str (WebSocket... -> coroutine a) -> Response
  #:
  websockets = n endpoint handler _sync: dict! ~> @websocket $ io ->
    (@app, endpoint) in _sync =>
      fin = asyncio.Future loop: @loop
      syn = _sync.pop (@app, endpoint)
      syn.set_result (io, fin)
      yield from fin
      yield from $ io.close 0

    socks = [io,]
    abort = []

    read = asyncio.async loop: @loop
      # NOTE: this client should NOT send anything before all websockets are connected.
      # TODO: find a better way to detect premature disconnects. `@reader._eof` does not
      #       seem to get set on a disconnect.
      # TODO: a better algorithm that would automatically drop disconnected clients
      #       and wait for `n` *connected* websockets.
      where except
        _       => yield from (@reader._waiter = @reader._create_waiter 'read')
        finally => @reader._waiter = None

    except
      _ =>
        except
          _ => for _ in (1..n) =>
            sync = _sync !! (@app, endpoint) = asyncio.Future loop: @loop
            wait = read, sync
            done, _ = yield from $ asyncio.wait wait loop: @loop return_when: asyncio.FIRST_COMPLETED
            read in done => raise $ asyncio.CancelledError
            sock, fin = yield from sync
            socks.append sock
            abort.append fin
          finally =>
            _sync.pop (@app, endpoint) None
            except err => read.cancel!, yield from read
                   err :: asyncio.CancelledError =>
        yield from $ handler *: socks
      finally => for waiter in abort => not waiter.done! => waiter.set_result None

  #: Read frames from multiple websockets at once, return a (websocket, frame) pair
  #: every time a frame is received.
  #:
  #: websocket_mux :: WebSocket... -> coroutine (WebSocket, Message)
  #:
  websocket_mux = *: socks ~>
    socks = dict
      where for s in socks => yield (asyncio.async loop: @loop $ iter s, s)

    PseudoCoroutine = subclass object where __iter__ = _ ->
      done, _ = yield from $ asyncio.wait socks loop: @loop return_when: asyncio.FIRST_COMPLETED
      done =>
        sock = socks.pop $ fst done
        socks !! asyncio.async loop: @loop (iter sock) = sock
        sock, yield from $ fst done
    PseudoCoroutine!


#: Start a client-side WebSocket connection.
#:
#: client :: str StreamReader StreamWriter -> WebSocket
#:
client = path rd wr ->
  key = base64.b64encode $ bytes (where for _ in range 16 => yield $ random.randrange 256)
  wr.write $ b'GET ' + path.encode 'latin-1' + b' HTTP/1.1\r\n'
  wr.write $ b'Upgrade: websocket\r\n'
  wr.write $ b'Connection: upgrade\r\n'
  wr.write $ b'Sec-WebSocket-Version: 13\r\n'
  wr.write $ b'Sec-WebSocket-Key: ' + key +  b'\r\n'
  wr.write $ b'\r\n'

  header = yield from $ rd.readline!
  header != b'HTTP/1.1 101 Switching Protocols\r\n' => raise $ ConnectionError 'handshake failed'

  while True =>
    header = yield from $ rd.readline!
    header == b'\r\n' => break!
    n, val = header.split b' ' 1
    if n.lower! == b'sec-websocket-accept' =>
      # base64.b64encode (hashlib.sha1 $ @key.encode 'ascii' + GUID).digest!).decode 'ascii'
      chk = base64.b64decode val.strip!
      chk != (hashlib.sha1 $ key + GUID).digest! =>
        raise $ ConnectionError 'key check error'

  WebSocket rd wr
