import '/asyncio'
import '/base64'
import '/random'
import '/hashlib'
import '/itertools'

import 'route'
import 'response'


Error = subclass Exception where
GUID  = b"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
CONT  = 0x0
TEXT  = 0x1
DATA  = 0x2
CLOSE = 0x8
PING  = 0x9
PONG  = 0xa
SHORT = 0xFFFF
LONG  = 0xFFFFFFFFFFFFFFFF
!=?   = a b -> not $ b.lower!.strip! in list (map str.strip $ a.lower!.split ',')


#: ???
#:
#: parse :: StreamReader -> coroutine Message
#:
parse = buf ->
  fin, code, *data = yield from $ parse_frame buf

  while not fin =>
    fin, cont, part = yield from $ parse_frame buf
    cont != CONT => raise $ Error 'unexpected opcode in continuation frame'
    data.append part
  data = b''.join data

  if code != CLOSE => Message code data None
     otherwise     =>
       code = data !! slice None 2
       rest = data !! slice 2 None
       Message CLOSE rest (int.from_bytes code 'big')


#: ???
#:
#: parse_frame :: StreamReader -> coroutine (int, int, bytes)
#:
parse_frame = buf ->
  head = yield from $ buf.readexactly 2
  head = int.from_bytes head 'big'

  # fin -- 0 if more frames from the same message follow.
  # rsv -- reserved fields, must be 0.
  fin    = (head & 0x8000) >> 15
  rsv    = (head & 0x7000) >> 12
  code   = (head & 0x0F00) >> 8
  masked = (head & 0x0080) >> 7
  length = (head & 0x007F)

  rsv => raise $ Error 'non-zero reserved value'
  code > 0x7 and not fin      => raise $ Error => 'fragmented control frame'
  code > 0x7 and length > 125 => raise $ Error => 'control frame payload length invalid'

  length = if
    length == 126 => int.from_bytes (yield from $ buf.readexactly 2) 'big'
    length == 127 => int.from_bytes (yield from $ buf.readexactly 8) 'big'
    otherwise     => length

  mask = itertools.cycle $ if
    masked    => yield from $ buf.readexactly 4
    otherwise => 0, 0, 0, 0

  fin, code, bytes $ map (^) mask $ if
    length    => yield from $ buf.readexactly length
    otherwise => b''


Message = subclass object where
  __new__ = tp data extra ~>
    self = if
      tp != TEXT => bytes.__new__ DataMessage data
      otherwise  => str.__new__   TextMessage $ except
        err => data.decode 'utf-8'
        err :: UnicodeDecodeError => raise $ asyncio.CancelledError er

    self.tp    = tp
    self.extra = extra
    self

  is_ping  = ~> @tp == PING
  is_pong  = ~> @tp == PONG
  is_data  = ~> @tp == DATA
  is_text  = ~> @tp == TEXT
  is_close = ~> @tp == CLOSE


DataMessage = subclass Message bytes where
TextMessage = subclass Message str   where


WebSocket = subclass object where
  __init__ = self @loop @reader @writer ->
  __iter__ = self -> while True =>
    msg = except
      err => yield from $ parse @reader
      err :: asyncio.IncompleteReadError => raise asyncio.CancelledError
    if msg.is_ping  => yield from @pong
       msg.is_close => raise $ asyncio.CancelledError msg
       otherwise    => raise $ StopIteration msg

  _head    = code ln   ~> bytes (((code != CONT) << 7) | code, ln)
  _frame   = code data ~>
    ln = len data
    if ln <= 125   => @writer.write $ @_head code ln + data
       ln <= SHORT => @writer.write $ @_head code 126 + ln.to_bytes 2 'big' + data
       ln <= LONG  => @writer.write $ @_head code 127 + ln.to_bytes 8 'big' + data
       otherwise =>
         yield from $ @_frame code $ data !! slice None LONG
         yield from $ @_frame CONT $ data !! slice LONG None
    yield from @writer.drain!

  ping  = data ~> @_frame PING data
  pong  = data ~> @_frame PONG data
  data  = data ~> @_frame DATA data
  text  = data ~> @_frame TEXT $ data.encode 'utf-8'
  close = code: 1000 data: b'' ~>
    except err => yield from $ @_frame CLOSE $ code.to_bytes 2 'big' + data
           err :: ConnectionError =>
    raise $ asyncio.CancelledError 'closed from this side'

  #: Read frames from multiple websockets at once, return a (websocket, frame) pair
  #: every time a frame is received.
  #:
  #: mux :: WebSocket... -> coroutine (WebSocket, Message)
  #:
  mux = *: (socks:(self, *_)) ->
    socks = dict (where for s in socks => yield (asyncio.async loop: @loop $ iter s, s))

    PseudoCoroutine = subclass object where __iter__ = _ ->
      done, _ = yield from $ asyncio.wait socks loop: @loop return_when: asyncio.FIRST_COMPLETED
      done =>
        sock = socks.pop $ fst done
        socks !! asyncio.async loop: @loop (iter sock) = sock
        sock, yield from $ fst done
    PseudoCoroutine!


Response = subclass response.Response where
  #: A WebSocket handshake `Response`.
  #:
  #: key     :: str -- `Sec-WebSocket-Key` of the request.
  #: handler :: Reader Writer -> coroutine a
  #:
  __init__ = handler @key @req @kwargs ~>
    @handler = asyncio.coroutine handler
    response.Response.__init__ self 101 dict! b''

  #: WebSocket handshake headers.
  #:
  #: defheaders :: dict str str
  #:
  defheaders = ~> dict'
    'Upgrade',    'websocket'
    'Connection', 'upgrade'
    'Sec-WebSocket-Accept',
      (base64.b64encode (hashlib.sha1 $ @key.encode 'ascii' + GUID).digest!).decode 'ascii'

  #: Start a WebSocket session.
  #:
  #: communicate :: StreamReader StreamWriter -> coroutine a
  #:
  communicate = reader writer ~> @handler @req **: @kwargs $ WebSocket @req.loop reader writer


#: Create a request handler that initiates a WebSocket connection
#:
#: endpoint :: (Request WebSocket -> coroutine a) -> (Request -> coroutine Response)
#:
endpoint = handler -> route.wraps handler $ **: k ~>
  if @method != 'GET' => @abort 405 headers: (dict allow: 'GET')
     @headers.get 'Upgrade'    !=? 'websocket' => @abort 400 'This is a websocket node.'
     @headers.get 'Connection' !=? 'upgrade'   => @abort 400 '`Connection: upgrade`?'

  ver = @headers.get 'Sec-WebSocket-Version'
  key = @headers.get 'Sec-WebSocket-Key'

  if not $ ver == '13' => @abort 400 'Unsupported WebSocket version.'
     not $ (except
       err => len (base64.b64decode key) == 16
       err :: Exception => False) => @abort 400 'WebSocket handshake error.'
  Response handler key self k


#: Do the same thing as `endpoint`, but with multiple connections.
#: The handler is called once `n` connections are available.
#:
#: aggregate :: int (Request WebSocket... -> coroutine a) -> (Request -> coroutine Response)
#:
aggregate = n handler ->
  # Ok, so differentiating between endpoints is hard. I give up.
  # We'll just assume "same path = same endpoint".
  datamap = dict!

  endpoint $ route.wraps handler $ __io **: k ~>
    # So the algorithm is this: we spawn a task that monitors a set of connections.
    # If its size reaches 0, the task exits. If it reaches `n`, the task calls
    # the handler. Meanwhile, the actual request-handling tasks add their connections
    # to the set, then wait until either the task exits or the connection is closed,
    # then remove their connection from the set. Simple.
    task, conns, event, stop = datamap.get @fullpath (None, None, None, None)
    task is None =>
      conns = set!
      event = asyncio.Event loop: @loop
      stop  = asyncio.Event loop: @loop
      task  = asyncio.async loop: @loop
        where except
          err     => while 0 < len conns < n => yield from event.wait!, event.clear!
          finally =>
            datamap.pop @fullpath None
            except
              inner => not err and conns => yield from $ handler self conns **: k
              inner :: ConnectionError        =>
              inner :: ConnectionResetError   =>
              inner :: asyncio.CancelledError =>
              finally => stop.set!
      datamap !! @fullpath = task, conns, event, stop

    conns.add __io
    event.set!
    except
      _ =>
        yield from stop.wait!
        yield from $ __io.close 1001
      finally =>
        conns.remove __io
        event.set!


#: Start a client-side WebSocket connection.
#:
#: client :: str StreamReader StreamWriter -> WebSocket
#:
client = path rd wr ->
  key = base64.b64encode $ bytes (where for _ in range 16 => yield $ random.randrange 256)
  wr.write $ b'GET ' + path.encode 'latin-1' + b' HTTP/1.1\r\n'
  wr.write $ b'Upgrade: websocket\r\n'
  wr.write $ b'Connection: upgrade\r\n'
  wr.write $ b'Sec-WebSocket-Version: 13\r\n'
  wr.write $ b'Sec-WebSocket-Key: ' + key +  b'\r\n'
  wr.write $ b'\r\n'

  header = yield from $ rd.readline!
  header != b'HTTP/1.1 101 Switching Protocols\r\n' => raise $ ConnectionError 'handshake failed'

  while True =>
    header = yield from $ rd.readline!
    header == b'\r\n' => break!
    n, val = header.split b' ' 1
    if n.lower! == b'sec-websocket-accept' =>
      # base64.b64encode (hashlib.sha1 $ @key.encode 'ascii' + GUID).digest!).decode 'ascii'
      chk = base64.b64decode val.strip!
      chk != (hashlib.sha1 $ key + GUID).digest! =>
        raise $ ConnectionError 'key check error'

  WebSocket rd._loop rd wr
