import '/asyncio'
import '/base64'
import '/hashlib'
import '/itertools'

import 'response'


Error = subclass Exception where
GUID  = b"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
CONT  = 0x0
TEXT  = 0x1
DATA  = 0x2
CLOSE = 0x8
PING  = 0x9
PONG  = 0xa
SHORT = 0xFFFF
LONG  = 0xFFFFFFFFFFFFFFFF
!=?   = a b -> not $ b.lower!.strip! in list (map str.strip $ a.lower!.split ',')


#: ???
#:
#: parse :: StreamReader -> coroutine Message
#:
parse = buf ->
  fin, code, *data = yield from $ parse_frame buf

  while not fin =>
    fin, cont, part = yield from $ parse_frame buf
    cont != CONT => raise $ Error 'unexpected opcode in continuation frame'
    data.append part
  data = b''.join data

  if code != CLOSE => Message code data None
     otherwise     =>
       code = data !! slice None 2
       rest = data !! slice 2 None
       Message CLOSE rest (int.from_bytes code 'big')


#: ???
#:
#: parse_frame :: StreamReader -> coroutine (int, int, bytes)
#:
parse_frame = buf ->
  head = yield from $ buf.readexactly 2
  head = int.from_bytes head 'big'

  # fin -- 0 if more frames from the same message follow.
  # rsv -- reserved fields, must be 0.
  fin    = (head & 0x8000) >> 15
  rsv    = (head & 0x7000) >> 12
  code   = (head & 0x0F00) >> 8
  masked = (head & 0x0080) >> 7
  length = (head & 0x007F)

  rsv => raise $ Error 'non-zero reserved value'
  code > 0x7 and not fin      => raise $ Error => 'fragmented control frame'
  code > 0x7 and length > 125 => raise $ Error => 'control frame payload length invalid'

  length = if
    length == 126 => int.from_bytes (yield from $ buf.readexactly 2) 'big'
    length == 127 => int.from_bytes (yield from $ buf.readexactly 8) 'big'
    otherwise     => length

  mask = itertools.cycle $ if
    masked    => yield from $ buf.readexactly 4
    otherwise => 0, 0, 0, 0

  fin, code, bytes $ map (^) mask $ if
    length    => yield from $ buf.readexactly length
    otherwise => b''


Message = subclass bytes where
  __new__ = tp data extra ~>
    self = bytes.__new__ self data
    self.tp    = tp
    self.extra = extra
    self

  is_ping  = ~> @tp == PING
  is_pong  = ~> @tp == PONG
  is_data  = ~> @tp == DATA
  is_text  = ~> @tp == TEXT
  is_close = ~> @tp == CLOSE


WebSocket = subclass object where
  __init__ = self @reader @writer ->
  __iter__ = self -> while True =>
    msg = except
      err => yield from $ parse @reader
      err :: asyncio.IncompleteReadError => raise asyncio.CancelledError
    if msg.is_ping  => yield from @pong
       msg.is_close => raise $ asyncio.CancelledError msg
       otherwise    => raise $ StopIteration msg

  _head    = code ln   ~> bytes (((code != CONT) << 7) | code, ln)
  _frame   = code data ~>
    ln = len data
    if ln <= 125   => @writer.write $ @_head code ln + data
       ln <= SHORT => @writer.write $ @_head code 126 + ln.to_bytes 2 'big' + data
       ln <= LONG  => @writer.write $ @_head code 127 + ln.to_bytes 8 'big' + data
       otherwise =>
         yield from $ @_frame code $ data !! slice None LONG
         yield from $ @_frame CONT $ data !! slice LONG None
    yield from @writer.drain!

  ping  = data ~> @_frame PING data
  pong  = data ~> @_frame PONG data
  text  = data ~> @_frame TEXT data
  data  = data ~> @_frame DATA data
  close = code: 1000 data: b'' ~> @_frame CLOSE $ code.to_bytes 2 'big' + data


Response = subclass response.Response where
  #: A WebSocket handshake `Response`.
  #:
  #: key     :: str -- `Sec-WebSocket-Key` of the request.
  #: handler :: Reader Writer -> coroutine a
  #:
  __init__ = handler @key ~>
    @handler = asyncio.coroutine handler
    response.Response.__init__ self 101 dict! b''

  #: WebSocket handshake headers.
  #:
  #: defheaders :: dict str str
  #:
  defheaders = ~> dict'
    'Upgrade',    'websocket'
    'Connection', 'upgrade'
    'Sec-WebSocket-Accept',
      (base64.b64encode (hashlib.sha1 $ @key.encode 'ascii' + GUID).digest!).decode 'ascii'

  #: Start a WebSocket session.
  #:
  #: communicate :: StreamReader StreamWriter -> coroutine a
  #:
  communicate = reader writer ~> @handler $ WebSocket reader writer


ContextAware = subclass object where
  #: Create a WebSocket from this request.
  #:
  #: websocket :: (Reader Writer -> coroutine a) -> Response
  #:
  websocket = handler ~>
    if @method != 'GET' => @abort 405 headers: (dict allow: 'GET')
       @headers.get 'Upgrade'    !=? 'websocket' => @abort 400 'This is a websocket node.'
       @headers.get 'Connection' !=? 'upgrade'   => @abort 400 '`Connection: upgrade`?'

    ver = @headers.get 'Sec-WebSocket-Version'
    key = @headers.get 'Sec-WebSocket-Key'

    if not $ ver in ('13', '8', '7') => @abort 400 'Unsupported WebSocket version.'
       not $ (except
         err => len (base64.b64decode key) == 16
         err :: Exception => False) => @abort 400 'WebSocket handshake error.'
    Response handler key
