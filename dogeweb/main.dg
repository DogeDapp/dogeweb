import '/socket'
import '/logging'

import '/asyncio'
import '/asyncio/TimeoutError'
import '/asyncio/CancelledError'
import '/asyncio/IncompleteReadError'

import 'http'
import 'request'
import 'response'
import 'response/Abort'

SOCKET_KEEPALIVE = hasattr socket 'SO_KEEPALIVE'


Server = subclass object where
  __init__ = handler onerror: None timeout: 15 ~>
    @timeout = timeout
    @handler = handler
    @onerror = onerror or @error
    @log     = logging.getLogger 'dogeweb'
    None

  #: Synchronously start a server. See `asyncio.start_server` for arguments.
  #:
  #: run :: * ** -> ()
  #:
  run = *: a loop: None **: k ~>
    loop = loop or asyncio.get_event_loop!
    srv  = loop.run_until_complete $ self loop *: a **: k
    except _       => loop.run_forever!
           finally =>
             srv.close!
             loop.run_until_complete srv.wait_closed!

  #: Asynchronously start a server. See `asyncio.start_server` for arguments.
  #:
  #: () :: EventLoop * ** -> coroutine AbstractServer
  #:
  __call__ = loop *: a **: k ~> asyncio.start_server loop: loop *: a **: k $ reader writer -> except
    err =>
      SOCKET_KEEPALIVE =>
        sock = writer.transport.get_extra_info 'socket'
        sock.setsockopt socket.SOL_SOCKET socket.SO_KEEPALIVE 1

      while True =>
        req = request.Request @handler reader writer @log *:
          except
            e2 => yield from $ asyncio.wait_for timeout: @timeout $ http.io_request reader
            e2 :: ValueError          => @log.debug 'bad request' exc_info: 1, raise CancelledError
            e2 :: TimeoutError        => raise CancelledError
            e2 :: IncompleteReadError => raise CancelledError

        resp = except
          outer => except
            inner => yield from $ response.responsify $ @handler req
            inner :: Abort          => raise inner
            inner :: CancelledError => raise inner
            inner :: Exception      => req.abort 500  # `inner` is stored as `__context__`.
          outer :: Abort => except
            middle => except
              inner => yield from $ response.responsify $ @onerror req outer
              inner :: Abort          => raise inner
              inner :: CancelledError => raise inner
              inner :: Exception      => req.abort 500
            middle :: Abort => yield from $ response.responsify $ @error req middle

        yield from $ http.io_response writer req.version resp.code resp.headers resp.data
        yield from $ resp.communicate reader writer
        close = 'close' in resp.headers.get 'connection' '' or req.version < (1, 1) or
                'close' in req .headers.get 'connection' '' or 'upgrade' in resp.headers
        close => raise CancelledError
    err :: ConnectionError =>
    finally                => writer.close!

  #: The default error handler. Do not use it. EVER.
  #:
  #: error :: Request Abort -> Response
  #:
  error = req err ~>
    err.code == 500 => @log.error 'unhandled error' exc_info: 1
    err.code, err.headers, '''<!doctype html>
      <html>
        <head>
          <title>{0.code} â€” {0.name}</title>
          <style>p[data-has-url="False"] {{ display: none; }}</style>
        </head>
        <body>
          <h1>{0.code} {0.name}</h1>
          <p>{0.description}</p>
          <p data-has-url="{1}">Though <a href="{2}">a different URL</a> is available.</p>
        </body>
      </html>'''.format err ('location' in err.headers) (err.headers.get 'location')
