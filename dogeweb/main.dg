import '/socket'
import '/logging'

import '/asyncio'
import '/asyncio/TimeoutError'
import '/asyncio/CancelledError'
import '/asyncio/IncompleteReadError'

import 'http'
import 'request'
import 'response'
import 'response/Abort'

SOCKET_KEEPALIVE = hasattr socket 'SO_KEEPALIVE'


Protocol = subclass asyncio.streams.StreamReaderProtocol where
  __init__ = handler onerror timeout: 30 loop: None ~>
    @handler = handler
    @onerror = onerror or @error
    @timeout = timeout
    @loop    = loop or asyncio.get_event_loop!
    @log     = logging.getLogger $ 'dogeweb.protocol.{}'.format $ id self
    @task    = None
    (super Protocol self).__init__ (asyncio.streams.StreamReader loop: loop) @connected loop: loop

  connected = reader writer ~>
    @reader    = reader
    @writer    = writer
    @transport = writer.transport
    @task      = asyncio.async @start loop: @loop

    SOCKET_KEEPALIVE =>
      sock = @writer.transport.get_extra_info 'socket'
      sock.setsockopt socket.SOL_SOCKET socket.SO_KEEPALIVE 2

  start = ~>
    close = False
    while not close => except
      err =>
        reqd  = yield from $ asyncio.wait_for timeout: @timeout $ http.io_request self
        req   = request.Request self *: reqd
        resp  = except
          outer => except
            # Layer 1. Call into the default handler.
            inner => yield from $ response.responsify $ @handler req
            inner :: Abort          => raise inner
            inner :: CancelledError => raise inner
            inner :: Exception      => req.abort 500  # `inner` is stored as `__context__`.
          outer :: CancelledError => raise outer
          outer :: Abort          => except
            middle => except
              # Layer 2. The default handler failed or raised an HTTP error.
              #          Call into the error handler.
              inner => yield from $ response.responsify $ @onerror req outer
              inner :: Abort     => raise inner
              inner :: Exception => req.abort 500
            middle :: Abort =>
              # Layer 3. The error handler FAILED TOO. Use a safe default.
              # If *this* fails, we're doomed.
              yield from $ @error req middle
        close = if
          'close'      in resp.headers.get 'connection' '' => True
          'close'      in req .headers.get 'connection' '' => True
          'keep-alive' in req .headers.get 'connection' '' => False
          otherwise => req.version < (1, 1)
        yield from $ resp.write_all @writer req.version
      err :: IncompleteReadError => @log.debug 'disconnected or bad request'
      err :: ConnectionError     => @log.debug 'connection failure (tcp keepalive timeout?)'
      err :: CancelledError      => @log.debug 'cancelled'
      err :: TimeoutError        => @log.debug 'keep-alive timeout'
      err :: ValueError          => @log.debug 'bad request'
      err :: Exception           => @log.exception 'failed to handle a request'
      finally                    => close |= bool err
    @transport.close!

  #: The default error handler. Do not use it. EVER.
  #:
  #: error :: Request Abort -> Response
  #:
  error = req err ~>
    if err.code == 500 =>
      orig = err.__context__
      info = type orig, orig, orig.__traceback__  # Python's exception handling is stupid.
      @log.error 'failed to handle a request' exc_info: info
    response.Response err.code err.headers $ b'Error ' + (str err.code).encode 'ascii' + b'\r\n'


Server = subclass object where
  #: `Protocol` is actually just a single connection.
  #:
  #: handler :: typeof Protocol.handler
  #: onerror :: typeof Protocol.onerror
  #:
  __init__ = handler onerror: None **: kwargs  ~>
    @handler = handler
    @onerror = onerror
    @kwargs  = kwargs
    None

  #: Create a new connection factory.
  #:
  #: () :: (Optional EventLoop) -> (-> Protocol)
  #:
  __call__ = loop: None ~> (-> Protocol @handler @onerror loop: loop **: @kwargs)

  #: Start the dev server. `gunicorn` had an asyncio worker, I think?
  #:
  #: run :: str int -> ()
  #:
  run = host port loop: None ~>
    loop = loop or asyncio.get_event_loop!
    srv  = loop.run_until_complete $ loop.create_server (self loop) host port
    except err => loop.run_forever!
           err :: KeyboardInterrupt =>
