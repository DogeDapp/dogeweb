import '/socket'
import '/logging'

import '/asyncio'
import '/asyncio/TimeoutError'
import '/asyncio/CancelledError'
import '/asyncio/IncompleteReadError'

import 'http'
import 'request'
import 'response'
import 'response/Abort'

SOCKET_KEEPALIVE = hasattr socket 'SO_KEEPALIVE'


Server = subclass object where
  __init__ = handler onerror: None timeout: 5 ~>
    @timeout = timeout
    @handler = handler
    @onerror = onerror or @error
    None

  #: Synchronously start a server. See `asyncio.start_server` for arguments.
  #:
  #: run :: * ** -> ()
  #:
  run = *: a loop: None **: k ~>
    loop = loop or asyncio.get_event_loop!
    srv  = loop.run_until_complete $ self loop *: a **: k
    except _       => loop.run_forever!
           finally =>
             srv.close!
             loop.run_until_complete srv.wait_closed!

  #: Asynchronously start a server. See `asyncio.start_server` for arguments.
  #:
  #: () :: EventLoop * ** -> coroutine AbstractServer
  #:
  __call__ = loop *: a **: k ~> asyncio.start_server loop: loop *: a **: k $ reader writer ->
    SOCKET_KEEPALIVE =>
      sock = writer.transport.get_extra_info 'socket'
      sock.setsockopt socket.SOL_SOCKET socket.SO_KEEPALIVE 2

    log   = logging.getLogger 'dogeweb'
    close = False
    while not close => except
      err =>
        reqd  = yield from $ asyncio.wait_for timeout: @timeout $ http.io_request reader
        req   = request.Request @handler reader writer log *: reqd
        resp  = except
          outer => except
            # Layer 1. Call into the default handler.
            inner => yield from $ response.responsify $ @handler req
            inner :: Abort          => raise inner
            inner :: CancelledError => raise inner
            inner :: Exception      => req.abort 500  # `inner` is stored as `__context__`.
          outer :: CancelledError => raise outer
          outer :: Abort          => except
            middle => except
              # Layer 2. The default handler failed or raised an HTTP error.
              #          Call into the error handler.
              inner => yield from $ response.responsify $ @onerror req outer
              inner :: Abort     => raise inner
              inner :: Exception => req.abort 500
            middle :: Abort =>
              # Layer 3. The error handler FAILED TOO. Use a safe default.
              # If *this* fails, we're doomed.
              yield from $ @error req middle
        close = if
          'close'      in resp.headers.get 'connection' '' => True
          'close'      in req .headers.get 'connection' '' => True
          'keep-alive' in req .headers.get 'connection' '' => False
          otherwise => req.version < (1, 1) or 'upgrade' in resp.headers
        yield from $ resp.write_all writer req.version
      err :: IncompleteReadError => log.debug 'disconnected'
      err :: ConnectionError     => log.debug 'connection failure (tcp keepalive timeout?)'
      err :: CancelledError      => log.debug 'cancelled'
      err :: TimeoutError        => log.debug 'keep-alive timeout'
      err :: ValueError          => log.debug 'disconnected or bad request'
      err :: Exception           => log.exception 'failed to handle a request'
      finally                    => close |= bool err
    writer.transport.close!

  #: The default error handler. Do not use it. EVER.
  #:
  #: error :: Request Abort -> Response
  #:
  error = req err ~>
    if err.code == 500 and err.__context__ =>
      orig = err.__context__
      info = type orig, orig, orig.__traceback__  # Python's exception handling is stupid.
      req.log.error 'failed to handle a request' exc_info: info
    response.Response err.code err.headers $ ('Error {}\r\n'.format err.code).encode 'ascii'
