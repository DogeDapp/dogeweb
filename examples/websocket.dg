import '/os'
import '/itertools'
import '/collections'

import '/dogeweb'
import '/dogeweb/r'
import '/dogeweb/websocket'


monotonic = itertools.count!
clients   = set!


app = dogeweb.app $ r.file
  '/', r.upgrade
    # `r.upgrade` routes between protocols.
    # If the client does not want to change protocols, it will use `http`.
    'http', ~> @static attachment: False $ os.path.join (os.path.dirname __file__) 'websocket.html'

    # `request.websocket handler` returns a `Response` that initiates
    # a websocket handshake and calls into the handler when done.
    'websocket', ~> @websocket $ input output ->
      id  = next monotonic
      idb = (str id).encode 'ascii'
      # `output` has five methods:
      #   * `ping` requests a `pong`;
      #   * `pong` responds to a `ping`;
      #   * `close [code] [message]` gracefully ends the connection;
      #   * `data something` transfers some binary data;
      #   * `text something` transfers text, but you should encode it anyway.
      for client in clients => yield from $ client.text $ b'S ' + idb + b' connected'
      clients.add output

      except
        err => while True =>
          # The input queue is a coroutine that returns the next message.
          # If there are no more messages to be consumed, it cancels this task (i.e.
          # raises `asyncio.CancelledError`.)
          msg = yield from input

          # A message is a bytestring with additional attributes `tp` (the opcode),
          # `is_text`, `is_data`, `is_ping`, and `is_pong`. (Pings are handled automatically.)
          if msg.is_text => for w in clients => yield from $ w.text $ b'M ' + idb + b' ' + msg
             msg.is_data => for w in clients => yield from $ w.data $ b'M ' + idb + b' ' + msg
        finally =>
          clients.remove output
          for client in clients => yield from $ client.text $ b'S ' + idb + b' disconnected'


app.run '0.0.0.0' 8000
